## 1、 MVCC
1. MVCC是什么：多版本并发控制
2. MVCC如何实现的：依赖于隐藏字段。Read View、undolog。
	1. 隐藏字段：
		1. DB_TRX_ID:表示最后一次更新或插入该行的事务.
		2. DB_ROLL_PTR:回滚指针。指向该行undo log
		3. DB_ROW_ID：如果没有设置主键切没有位移非控索引是。用该ID生成聚组索引。
	2. ReadView
		1.  m_low_limit_id: 目前出现的最大的事务ID+1。大于等于这个ID的数据版本均不可见。
		2.  m_up_id:活跃事务列表中最小的事务ID。小于等于这个事务ID的数据版本均可见
		3.  m_ids：创建事务时其他未提交的活跃事务ID列表。
		4.  m_create_trx_id:创建该Read View的事务ID。
	3. undo-log
		1. 两个作用：
			1. 当事务回滚时将叔恢复到修改前的样子。
			2. 另一个作用是MVCC，当读取事务时，若该记录被其他事务占用或者当前版本对该事务不可见，则可以通过undo-log读取之前的版本数据。以此实现非锁定读。
## 2、数据库三范式
 - 第一范式：属性不可分割。
 - 第二范式： 非主属性都依赖于主属性。
 - 第三范式： 属性之间的传递依赖关系。

## 3、事务的隔离级别 ##
1. 脏读：读取了其他事务未提交的诗句
2. 不可重复读： 读取了其他事务修改完的数据。 
3. 幻读：事务执行过程中。其他事务插入或者删除了数据
4. 事务的隔离级别
	1. 读未提交
	2. 读已提交
	3. 可重读
	4. 线性化
5. 事务的ACID原则：
	1. 原子性：事务是最小的执行单位
	2. 一致性：事务执行前后，数据保持一致性。
	3. 隔离性：事务之前不会相互影响。
	4. 持久性：事务提交会，对数据的修改是永久的。redo-log.

## 4、Redis ##
### 4.1Redis的数据类型
1. String k/v
2. List
3. Set
4. ZSet
5. Hash

### 4.2  Redis的3种常用的读写策略。
 - 1、Cache Aside Pattern 旁路缓存模式
   - 读：
	 - 1、从cache种读取数据，如果缓存种有数据的直接返回。
	 - 2、cache中读取不到的话，就从db中获取数据返回
	 - 3、再把数据放到cache中.
   - 写：
	 - 1、先更新DB
	 - 2、然后直接删除cache。
	- 旁路缓存模式缺陷：
		- 1. 首次请求的数据在cache中不存在，
		- 2. 写操作比较频繁的话，会导致缓存中的数据频繁被删除，会影响缓存命中率。
	- 解决办法：
		- 数据库强一致性场景：更新db的时候同样更新cache，不过我们需要加一个锁/分布式锁来抱保证更新cache的时候不存在线程安全问题。
		- 可以短暂的允许数据库和缓存不一致的场景：更新DB的时候同时更新cache，但是给换粗加一个比较短的过期时间。
	 
 - 2、 Read/Write Through Pattern（读写穿透）
	- 读:
		- 1、从cache中读取数据，如果缓存中存在数据的话直接返回数据
	    - 2、如果cache中没有数据的话，先db加载，写入到cache中后返回响应。
	- 写
		- 1、先查cache，cache中不存在，直接更新db。
		- 2、cache中存在，则先更新cache，然后cache服务自己更新DB（同步更新cache和db）。
	- 读写穿透的缺陷：
		
 - 3、Write Behind Pattern（异步缓存写入
	- 这种方式和读写穿透的方式很相似。 两者都是有cache服务来负责cache和db读写。但是两者又有很大的不同，读写穿透是同步更细cache和db，而Write Behind则是只是更新缓，不直接更新DB，而是改为异步批量的方式更新DB
	
### 4.3 如何保证Redis和数据库的一致性。
1. 更新缓存数据的4种方案。ccc
	- 先更新缓存，再更新数据库
	- 先更数据库，再更新缓存
	- 先淘汰数据，再更新数据库
	- 先更新数据库，再淘汰数据
	
2. 更新、淘汰数据优缺点。
	- 淘汰数据
		- 优点：操作方式简单。
		- 缺点：淘汰数据后，下一次无法在缓存中查询到，会有一次cache-miss。
	- 更新数据
		- 优点：缓存命中率高，不会造成cache-miss。
		- 缺点：1、 更新cache消耗更大。 2、并发更新到处数据不一致问题。
	
3. 保持数据一致性的策略。
	1. 延时双删：(1)写请求 (2)删除缓存 (3)更新数据库 (4)休眠一会，再次删除缓存。
	2. 删除缓存重试机制：
		- 写请求更新数据库
		- 缓存因为某些原因删除失败
	    - 把删除的Key放入消息队列。
		- 要删除的key拉出来。
		- 重试删除操作。
	3. 读取数据库的binlog日志来异步淘汰缓存。
	
4. 保证本地缓存和分布式缓存的一致性。
	1. 可以使用Redis本身的Pub/Sub机制，分布式集群的所有节点都订阅删除本地缓存频道。删除Redis的节点，同时发布删除本地缓存消。
	2. 引入专业的消息队列，保证消息的可靠性，但是增加了系统的复杂性。
	3. 设置适当的过期时间兜底，本地缓存可以设置相对短一点的过期时间。
	
### 4.4 Redis分区方案
1. 节点取余
2. 一致性Hash分区，
3. 虚拟槽分区
	
### 4.5 Redis集群
1. redis集群的三种模式
	- 1. 主从模式
         1. 集群介绍
          - (1)主从模式里使用一个redis实例作为主机，其余多个实例作为备份集（slave）
          - (2)master用来支持数据的写入和读取操作，而slave节点支持读取以及master的数据同步
          - (3)在整个架构中，master和slave实例里的数据完全一致。
         2. 主从复制原理：
          - 全量同步:
            - 1、当从节点启动时，向主节点发送SYNC消息，
            - 2、主节点收到SYNC命令后，开始在后台执行保存快照的命令生成RDB文件，使用缓冲记录此后执行的所有命令。
            - 3、主节点快照完成后，将快照文件和所有缓存命令发送给集群内的从节点，并在发送期间继续记录被执行的命令。
            - 4、主节点快照发送完成后向从节点发送所缓冲区的命令。
            - 5、从节点载入快照文件后，开始接受命令请求，执行收到的主节点缓冲区的写命令。
          - 增量同步:
            - 主从复制中因为网络原因造成数据丢失的场景，当从节点再次连接主节点。如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效的避免全量复制的过高开销。
         3. 主节点故障的处理方式：
      	  - 主从模式中，每个客户端连接redis实例都指定了ip和端口号。如果连接的redis实例因为故障下线了，则无法通知客户端连接其他客户端，因此只能手动操作。
         4. 不支持高可用
    - 2. 哨兵模式
          1. 集群介绍：和主从模式不一样的是，哨兵模式中增加了独立进程（即哨兵）来监控集群的一举一动。客户端在连接集群时，首先连接哨兵，通过哨兵查询主节点的地址，然后再去连接主节点信息进行数据交互。如果master异常，则会进行master-slave切换，将最优的一个slave切换为主节点。同时，哨兵持续监控挂掉的节点，待其恢复后，作为新的节点假如集群中。
          2. 主节点故障处理方式/哨兵工作方式：
          	- 1、每个哨兵每秒向集群中的master、slave以及其他哨兵发送一个Ping命令。
            - 2、如果某个实例距离最后一次有效回复ping命令的时间超过一定的值，则会被标记为下线。
            - 3、如果master被标记为主观下线，那么正在监视master的哨兵以每秒的频率确认其确实进入主观下线状态，且数量达到一定值时，master会被标记为下线，然后通知其他的服务器，修改配置文件，让他们切换主机。
            - 4、客户端在master节点发生故障时会向哨兵要地址，此时会获得最新的master节点地址。
          3. 扩容问题：哨兵模式的出现虽然解决了主从模式中master节点宕机不能自动切换的问题(即高可用)的问题。但是，随着业务的逐渐增长，不可避免需要对当前业务进行扩容。
            - 1、垂直扩容：通过增加master来增加容量
            - 2、水平扩容：通过增加节点来进行扩容，即在当前基础上再增加一个master节点。
              - 虽然垂直扩容方式很便捷，不需要添加多余的节点，但是机器的容量是有限的，最终还是需要通过水平扩容方式来解决。而水平扩容涉及到数据的迁移，且迁移过程中又要保证服务的可用性。因此，数据能不迁移，尽量不迁移。
              - 显然哨兵模式无法满足这种情形，因此redis-cluster应运而生。
       - 3. Redis-cluster模式
          1. 集群介绍：
             1. redis-cluster模式采用了无中心节点的方式来实现，每个主节点都会与其他节点保持连接。节点间通过gossip协议交换彼此的信息。同时每个主节点又有一个或者多个从节点。
             2. 客户端连接集群时，直接与redis集群的每个主节点连接，根据hash算法取模key存储在不同的hash槽上。
             3. 在集群中采用数据分片的方式，将redis集群分为16384个哈希槽。 这些哈希槽分别存储于三个主节点中。
             	- master1负责 0-5460号哈希槽。
                - master2负责 5461-10922哈希槽。
                - master3负责 10922-16383哈希槽。
             4. 每个节点会保存一份数据分布表，节点将自己的slot信息发送到其他节点，节点间不停地传递数据分布表。
             5. 客户端连接集群时，通过集群的某个节点地址进行连接。客户端尝试向这个节点执行命令时，比如获取某个key值，如果key所在的slot刚好在该节点上，则能够直接执行成功。如果slot不在该节点，则节点返回MOVED错误，同时把该slot对应的节点告诉客户端，客户端可以去该节点执行命令。