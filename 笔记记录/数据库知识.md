## 1、 MVCC
1. MVCC是什么：多版本并发控制
2. MVCC如何实现的：依赖于隐藏字段。Read View、undolog。
	1. 隐藏字段：
		1. DB_TRX_ID:表示最后一次更新或插入该行的事务.
		2. DB_ROLL_PTR:回滚指针。指向该行undo log
		3. DB_ROW_ID：如果没有设置主键切没有位移非控索引是。用该ID生成聚组索引。
	2. ReadView
		1.  m_low_limit_id: 目前出现的最大的事务ID+1。大于等于这个ID的数据版本均不可见。
		2.  m_up_id:活跃事务列表中最小的事务ID。小于等于这个事务ID的数据版本均可见
		3.  m_ids：创建事务时其他未提交的活跃事务ID列表。
		4.  m_create_trx_id:创建该Read View的事务ID。
	3. undo-log
		1. 两个作用：
			1. 当事务回滚时将叔恢复到修改前的样子。
			2. 另一个作用是MVCC，当读取事务时，若该记录被其他事务占用或者当前版本对该事务不可见，则可以通过undo-log读取之前的版本数据。以此实现非锁定读。
## 2、数据库三范式
 - 第一范式：属性不可分割。
 - 第二范式： 非主属性都依赖于主属性。
 - 第三范式： 属性之间的传递依赖关系。

## 3、事务的隔离级别 ##
1. 脏读：读取了其他事务未提交的诗句
2. 不可重复读： 读取了其他事务修改完的数据。 
3. 幻读：事务执行过程中。其他事务插入或者删除了数据
4. 事务的隔离级别
	1. 读未提交
	2. 读已提交
	3. 可重读
	4. 线性化
5. 事务的ACID原则：
	1. 原子性：事务是最小的执行单位
	2. 一致性：事务执行前后，数据保持一致性。
	3. 隔离性：事务之前不会相互影响。
	4. 持久性：事务提交会，对数据的修改是永久的。redo-log.

## 4、Redis ##
### 4.1Redis的数据类型
1. String k/v
2. List
3. Set
4. ZSet
5. Hash

### 4.2  Redis的3种常用的读写策略。
 - 1、Cache Aside Pattern 旁路缓存模式
   - 读：
	 - 1、从cache种读取数据，如果缓存种有数据的直接返回。
	 - 2、cache中读取不到的话，就从db中获取数据返回
	 - 3、再把数据放到cache中.
   - 写：
	 - 1、先更新DB
	 - 2、然后直接删除cache。
	- 旁路缓存模式缺陷：
		- 1. 首次请求的数据在cache中不存在，
		- 2. 写操作比较频繁的话，会导致缓存中的数据频繁被删除，会影响缓存命中率。
	- 解决办法：
		- 数据库强一致性场景：更新db的时候同样更新cache，不过我们需要加一个锁/分布式锁来抱保证更新cache的时候不存在线程安全问题。
		- 可以短暂的允许数据库和缓存不一致的场景：更新DB的时候同时更新cache，但是给换粗加一个比较短的过期时间。
	 
 - 2、 Read/Write Through Pattern（读写穿透）
	- 读:
		- 1、从cache中读取数据，如果缓存中存在数据的话直接返回数据
	    - 2、如果cache中没有数据的话，先db加载，写入到cache中后返回响应。
	- 写
		- 1、先查cache，cache中不存在，直接更新db。
		- 2、cache中存在，则先更新cache，然后cache服务自己更新DB（同步更新cache和db）。
	- 读写穿透的缺陷：
		
 - 3、Write Behind Pattern（异步缓存写入
	- 这种方式和读写穿透的方式很相似。 两者都是有cache服务来负责cache和db读写。但是两者又有很大的不同，读写穿透是同步更细cache和db，而Write Behind则是只是更新缓，不直接更新DB，而是改为异步批量的方式更新DB
	
### 4.3 如何保证Redis和数据库的一致性。
1. 更新缓存数据的4种方案。ccc
	- 先更新缓存，再更新数据库
	- 先更数据库，再更新缓存
	- 先淘汰数据，再更新数据库
	- 先更新数据库，再淘汰数据
	
2. 更新、淘汰数据优缺点。
	- 淘汰数据
		- 优点：操作方式简单。
		- 缺点：淘汰数据后，下一次无法在缓存中查询到，会有一次cache-miss。
	- 更新数据
		- 优点：缓存命中率高，不会造成cache-miss。
		- 缺点：1、 更新cache消耗更大。 2、并发更新到处数据不一致问题。
	
3. 保持数据一致性的策略。
	1. 延时双删：(1)写请求 (2)删除缓存 (3)更新数据库 (4)休眠一会，再次删除缓存。
	2. 删除缓存重试机制：
		- 写请求更新数据库
		- 缓存因为某些原因删除失败
	    - 把删除的Key放入消息队列。
		- 要删除的key拉出来。
		- 重试删除操作。
	3. 读取数据库的binlog日志来异步淘汰缓存。
	
4. 保证本地缓存和分布式缓存的一致性。
	1. 可以使用Redis本身的Pub/Sub机制，分布式集群的所有节点都订阅删除本地缓存频道。删除Redis的节点，同时发布删除本地缓存消。
	2. 引入专业的消息队列，保证消息的可靠性，但是增加了系统的复杂性。
	3. 设置适当的过期时间兜底，本地缓存可以设置相对短一点的过期时间。
	
### 4.4 Redis分区方案
1. 节点取余
2. 一致性Hash分区，
3. 虚拟槽分区
	
   