## 11、多线程的优点和缺点
- 优点：提高单个cpu和IO系统的效率；多核时代：充分利用多核cpu的能力。
- 缺点：线程不安全问题、内存泄露、死锁。
- 线程不安全问题：同一份数据，是否报数据正确性和一致性。是否有数据混乱、错误或者丢失。

## 12、 线程的状态
1. NEW
2. Runnable状态，调用start ，等待运行状态。 ready状态，获取cpu时间片后就是running状态。
3. Blocking 阻塞状态
4. WAITING 等待状态
5. timeWaiting 超时等待状态
6. Terminated 终止状态。

## 13、线程死锁的四大条件

- 什么是死锁：多个线程同时被阻塞，他们中的一个或者多个全部都在等待某个资源被释放。由于线程无线的被阻塞，因此程序不可能正常运行。

1. 互斥条件：一个资源同一时间内只能被一个线程所占用
2. 请求与保持条件：一个线程在请求某个资源而阻塞时，对已经获取的资源不会释放
3. 不剥夺条件：某个线程获取的资源，被能被其他线程强行剥夺，只能由自己释放
4. 循环等待：多个线程和资源之间形成首尾相连的请求和依赖关系

## 14、wait方法和sleep方法的区别
- wait方法释放锁，sleep方法不会
- wait用于线程间通信，sleep用于暂停执行
- wait方法线程不会主动苏醒，需要系统调用notify方法或者notifyAll，sleep可以，wait（long）可以
- sleep是Thread的静态方法，wait是Object中定义的方法。

## 15、volatile关键词

1. 保证变量的可见性
2. 禁止指令重排序。 （new 对象 1、给对象分配内存空间 2、初始化 3、将对象直线引用地址）

## 16、悲观锁和乐观锁

- 悲观锁：以最坏的情况考虑问题，每次访问资源的时候都有可能产生问题，每次访问资源都需要进行锁操作
- 乐观锁：以最好的情况考虑问题，每次访问的时候不会存在问题，只有在提交修改的时候去验证，资源是否已经被其他资源修改过了。

## 17、实现乐观锁：、
-1、版本号机制 2、CAS算法。

## 18、CAS算法怎么实现的。
- 1、E 一个预期值
- 2、V 要更新的变量值
- 3、N 拟写入的新值
 - 无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。
 - 当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V值。否则不会执行任何操作（比如替换是一个原子操作）




## 19、synchronized关键词：保证同一个时间内，是有一个线程能够访问代码块或者方法

- 1、修饰实例方法（锁当前对象）
- 2、修饰静态方法（锁当前类）
- 3、修饰代码块（？？任意）

## 20、synchronized和reenTrantLock区别和共同点

- 1、都是可重入锁
- 2、reenTrantLock可以实现公平锁
- 3、reenTrantLock的高级功能：
    - 等待可中断
    - 可实现公平锁
    - 可实现选择性通知。需要借助于Condition接口和newCondition()方法
- 4、synchronized依赖于JVM，而reenTrantLock依赖于API

### 1、synchronized的实现原理？

- 同步代代码块：底层依赖JVM完成，同步代码块的语义底层通过一个monitor对象来完成的。其实wait、notify等方法也依赖于monitor对象。
    - monitorenter命令：每个对象都是一个监视器锁（monitor）。当monitor被占用是就处于锁定状态，线程执行monitorenter命令尝试获取monitorenter的所有权。过程如下：
        - 1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1.该线程即为monitor的所有者。
        - 2 如果线程已经占有monitor，只是重新进入，则进入monitor的进入数加1.
        - 3、如果其他线程已经占用monitor，则该线程进入阻塞状态，知道monitor进入数为0，再重新尝试获取monitor的所有权。
    - monitorexit命令： ：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；。
- 同步方法：  方法的同步通过ACC_SYNCHRONIZED 标示符。JVM就是根据该标识付来实现同步方法的。当方方法调用时，调佣指令会检查方法的ACC_SYNCHRONIZED访问标识是否被设置，如果设置了，执执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行后再释放monitor。在方法执行期间。其他线程都无法获取同一个monitor独对象。

### 2、reenTrantLock的实现原理？

## 21、ThreadLocal

- 每个Thread拥有一个threadLocalMap类存储 。key是ThreadLocal变量，而value是值。 key是弱引用，value是强引用。

## 22、线程池的好处

- 1、降低资源消耗
- 2、提高响应速度
- 3、提高线程的可管理性

### 1、线程池的实现原理？

- 1、JVM先根据用户给定的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建后启动这些任务，如果正在运行的线程数量超过了最大线程数量(用户设置的线程池大小)，则超出数量的线程排队等候，在有任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。

### 2、线程池线程的计算方式。

- 根据计算方式是计算密集型还是IO密集型。
- 2、Nthreads = Ncpu x Ucpu x(1 + W/C)
    - W 线程等待时间。
    - C 线程计算时间。
    - Ucpu CPU使用率。

## 23、线程池的参数

1. coolPoolSize：任务队列未达到队列容量是，最大可同时运行的线程数量
2. maxPoolSize：任务队列达到队列容量时候，最大可同时运行的线程数量
3. workQueue：判断当前同时运行的线程数量是否达到了核心线程数，如果达到了，则将任务存放在该队列中。
4. keepAliveTime：
5. unit
6. ThreadFactory
7. handle：拒绝策略

## 26、并发编程的三个特性：

- 原子性
- 可见性
- 有序性


## 32、偏向锁、轻量级锁、重量级锁。

- 1、首先清楚Java对象头中的数据结构。
    - 1、MarkWord：用于存储对象自身的运行数据。如 HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等。
    - 2、类型指针：虚拟机通过这个指针确定该对象是哪个类的实例。
    - 3、数组长度
    - 4、对齐填充部分。
- MarkWord：不同锁的存储信息。
    - 无锁： 25bit HashCode + 4 bit对象分代年龄。 1 bit（是否是偏向锁） 2 bit（锁标志位）01
    - 偏向锁 ：23bit线程ID 2bit epoch 4bit对象分代年龄 1bit是否是偏向锁  2bit（锁标志位） 01 （cas替换线程ID）
    - 轻量级锁：30bit指向 线程栈锁记录的指针。 2bit锁标识位 00  （cas替换线程栈记录指针）
    - 重量级锁：指向锁监视器的指正。 2bit锁标识位 10
- 参考 【https://www.cnblogs.com/wuqinglong/p/9945618.html】


## 37、JUC是什么？

- JUC是 在Java 5.0添加的 java.util.concurrent包的简称，目的就是为了更好的支持高并发任务， 让开发者利用这个包进行的多线程编程时可以有效的减少竞争条件和死锁线程。
- JUC的5个部分：
    - 1、tools：CountDownLatch（闭锁）、Semaphore（信号量）、CyclicBarrier（栅栏）
    - 2、locks：
    - 3、executor:
    - 4、Collections：主要是提供线程安全的集合
    - 5、Atomic: 是JDK提供的一组原子操作类，

## 38、AQS介绍和原理？
- AQS介绍：AQS 的全称为 AbstractQueuedSynchronizer ，翻译过来的意思就是抽象队列同步器。这个类在 java.util.concurrent.locks 包下面。
- AQS就是一个抽象类，用于构建锁和同步器。
- AQS的核心思想：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 CLH 锁 （Craig, Landin, and Hagersten locks） 实现的。
- CLH锁：CLH 锁数据结构很简单，类似一个链表队列，所有请求获取锁的线程会排列在链表队列中，自旋访问队列中前一个节点的状态。当一个节点释放锁时，只有它的后一个节点才可以得到锁。CLH 锁本身有一个队尾指针 Tail，它是一个原子变量，指向队列最末端的 CLH 节点。每一个 CLH 节点有两个属性：所代表的线程和标识是否持有锁的状态变量。当一个线程要获取锁时，它会对 Tail 进行一个 getAndSet 的原子操作。该操作会返回 Tail 当前指向的节点，也就是当前队尾节点，然后使 Tail 指向这个线程对应的 CLH 节点，成为新的队尾节点。入队成功后，该线程会轮询上一个队尾节点的状态变量，当上一个节点释放锁后，它将得到这个锁。
- CLH锁作为自旋锁的改进，有以下几个优点：
    - 1、性能优异
    - 2、公平锁
    - 3、实现简单、易于理解
    - 4、扩展性强
    - 缺点： 1、因为有自旋操作，当锁持有时间长时会带来比较大的CPU开销
    - 2、CLH锁的功能单一，不改造不能支持复杂的功能。
- AQS对CLH队列的改进
- 1、扩展每个节点的状态 volatile int waitStatus
    - AQS 同样提供了该状态变量的原子读写操作，但和同步器状态不同的是，节点状态在 AQS 中被清晰的定义，如下表所示：
        - SIGNAL：表示该节点正常等待
        - PROPAGATE：应将releaseShared传播到其他节点。
        - CONDITION：该节点位于条件队列，不能用于同步队列节点
        - CANCELLED：由于超时、中断或其他原因，该节点被取消
- 2、显示地维护前驱节点和后驱节点
    - 上文我们提到在原始版本的 CLH 锁中，节点间甚至都没有互相链接。但是，通过在节点中显式地维护前驱节点，CLH 锁就可以处理“超时”和各种形式的“取消”：如果一个节点的前驱节点取消了，这个节点就可以滑动去使用前面一个节点的状态字段。
    - 因为 AQS 用阻塞等待替换了自旋操作，线程会阻塞等待锁的释放，不能主动感知到前驱节点状态变化的信息。AQS 中显式的维护前驱节点和后继节点，需要释放锁的节点会显式通知下一个节点解除阻塞，如下图所示，T1 释放锁后主动唤醒 T2，使 T2 检测到锁已释放，获取锁成功。
- 3、辅助 GC
    - JVM 的垃圾回收机制使开发者无需手动释放对象。但在 AQS 中需要在释放锁时显式的设置为 null，避免引用的残留，辅助垃圾回收。

## 39、AQS资源共享方式？
- AQS定了两种资源共享的方式：Exclusive（独占，只有一个线程能执行，入ReentrantLock）和Share（共享，多个线程可同时执行，入Semaphore/CountDownLatch）
- 一般来说，自定义同步器的共享方式要么是独占，要么是共享，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。

## 40、AQS自定以同步器？
- 同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样
- 使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。
- 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

## 24、JMM java内存模型：抽象了线程和主内存之间的关系。

- JMM是什么：Java定义的并发编程的一组规范，除了抽象线程和主内存之间的关系之外，其还规定了从Java代码到CPU可执行命令的这个转换过程要遵守哪些和并发相关的原则和规范。
- 主内存：所有线程创建的实例对象都存放在主内存中，不管是实例对象的成员变量还是方法中的局部变量
- 本地内存：每个线程都有一个私有的本地内存来保存共享变量的副本。每个线程都有自己的本地内存，无法访问其他线程的本地内存。

## 25、happen-before原则：

- 为了对编译器和处理器的约束尽可能少，只要不改变程序执行结果，编译器和处理起怎么进行重新排序优化都行。
- 对于改变程序执行结果的重排序，JMM要求编译器和处理器都禁止这种重排序。
- happen-before八大原则：
  - 1、程序次序规则：在一个线程内，按照控制流程，书写在前面的操作先行发生在发生在后面的操作。
  - 2、管制锁定规则：一个unlock操作先行发生于后面的锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。
  - 3、volatile 变量规则：对于一个volatile修饰的变量的写操作优先于发生于后面对这个变量的读操作。
  - 4、线程启动规则：Thread对象的start方法发生于此线程的每个动作之前。
  - 5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测。
  - 6、线程中断规则：对线程的interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。通过interrupted()方法检测是否有中断发生。
  - 7、对象终结规则：一个对象的初始化完成先行于他的finalize()方法。
  - 8、传递性：如果A先行发生于B，B先行发生于C，那么就可以得到A先行发生于C的结论。
- as-if-serial：不管怎么重新排序，单线程环境下的执行结果不能改变。

