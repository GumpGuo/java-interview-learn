## 1、Java SPI机制 ##
1. Server Provider Interface 服务提供者的接口
	例如： SLF4J（Simple Logging Facade for Java）是 Java 的一个日志门面（接口）
	实现有 LogBack,Log4j Log4j2 

## 2、Java对象的内存布局是什么样子的。
1. 对象头 MarkWord和ClassPointer部分
	1. MarkWord部分记录了一些列的标记为。比如偏向锁、GC信息等。
	2. ClassPointer记录了对象的内存地址信息。
2. Length：数组长度
3. instance data /Array instance 数组对象信息
4. Padding 填充部分、

## 3、泛型和泛型擦除 ##
1. 泛型：类型参数化。把类型明确的工作推迟到对象创建或者调佣方法的时候才去明确的特殊类型。
2. 泛型擦除： 泛型只在编译器中实现而非虚拟机中实现，所以要在虚拟机中进行泛型擦除。也就是说在编译阶段使用泛型，而在运行阶段进行擦除。
3. 泛型的作用
   1. 第一个是泛化。
   2. 第二个是类安全性。
   3. 第三是消除了强制类型转换，减少了出错的机会。
   4. 向后兼容。 
4. 泛型的好处
   1. 类安全性。编译器会帮助验证类型假设
   2. 消除了强制类型转换。
   3. 更高的运行效率。
   4. 潜在的性能收益：泛型为较大的优化带来可能。
	

## 4、Java的三大特性
 - 封装
   - 1、设置属性不可以被外部访问，但提供修改和属性值的方法。
   - 2、类的行为和属性看看成是不可分割的一部分。 
 - 继承
   - 1、子类可以拥有父类的属性和方法。
   - 2、可以操作父类的私有属性，但不能访问私有方法。可以重写父类的方法。	
 - 多态
   - 一个行为可以具有多个多个表现形式或者形态的能力
   - 方法重载和对象多态两种形式的多态。
		- 1、方法重载：指的是，一个类中可以有相同名称的方法。但入参的类型或者顺序不同。返回类型也可以不同，完成不同的功能。
		- 2、对象多态：父类的引用实现子类的实例。
	- 多态的特点：
		- 1、必须要子类继承某个类。
		- 2、调用了哪个方法，需要在程序运行时才能确定。
	    - 3、不能调用在父类中未定义的方法。
	    - 4、子类实现了父类的方法，则调用的实际是子类方法，否则调用的是父类的方法。
	- 多态的必要条件
		- 集成
	    - 重载
	    - 父类的引用指向子类的实例

## 5、Java创建对象的几种方式
 - 1、new关键词。
 - 2、Class类的newInstance方法。
 - 3、构造方法类的newInstance方法。 .class.getCon
 - 4、使用clone方法。
 - 5、使用反序列化。ObjectInputStream

## 6、Object中有哪些方法？
 - getClass
 - hashCode
 - equals
 - toString
 - clone 
 - notify
 - notifyAll
 - wait()
 - wait(long timeout)
 - wait(long timeout,long nanos)
 - finalize()

## 7、Java反射以及优缺点
 - Java反射：可以通过反射获取类的所有属性和方法，并执任意一个类的属性和方法。
 - 优缺点：
    - 优点：让代码更加灵活，为各种框架提供了便利。
	- 缺点：增加了安全问题：无视泛型参数的安全检查。反射的性能也比较差。
	

## 8、何谓注解。
 - 用于修饰类、方法、变量。在程序编译期间或者运行期间提供某些信息。
 - 编译器直接扫描：eg@Override 。运行期间通过发射获取。


## 9、抽象类和接口的区别
 - 相同点
1. 都可以用抽象方法。
2. 都可以有默认的实现方法。
3. 都不能被实例化
 -  不同点
1. 接口是对类行为的定义，或者只是一个表示，用于定义类有那些行为，实现类必须实现这些行为。而抽象类一般用于代码复用
2. 一个类可以实现多个接口但只能继承一个类。
3. 接口的成员变量是public static final类型的，且必须有初始值。而抽象类成员变量默认是defaule，可以在子类重新定义，也可以重新赋值。


## 10、进程和线程
1. 进程：
	进程：程序的一次执行过程，系统运行程序的基本单位。
	线程：和进程类似，是比进程更小的运行单位，一个进程运行时可以有多个线程。不同的是，进程可以共享队和方法区，且有自己私有的空间，

## 10、 JVM虚拟机
1. JVM内存分区
	 - 程序计数器：可以看作是当前程序所执行的字节码的行号指示器。
		- 1、记录字节码指令的行号。字节码解释器，通过改变程序计数器来一次读取指令。从而达到控制代码流程的作用。顺序执行、选择、循环、异常捕获等。
	    - 2、多线程运行时，记录下当前运行到的指令为止，下一次线程切换回来的时候能够继续运行。
	 - 虚拟机栈：操作数栈、局部变量表、动态链接、方法返回地址。
	 - 本地方法栈：
	 - 堆 ：存放对象
	 - 方法区 ：类信息、常量、静态变量

## 11、多线程的优点和缺点
 - 优点：提高单个cpu和IO系统的效率；多核时代：充分利用多核cpu的能力。
 - 缺点：线程不安全问题、内存泄露、死锁。
 - 线程不安全问题：同一份数据，是否报数据正确性和一致性。是否有数据混乱、错误或者丢失。

##  12、 线程的状态 ##
1. NEW
2. Runnable状态，调用start ，等待运行状态。 ready状态，获取cpu时间片后就是running状态。
3. Blocking 阻塞状态
4. WAITING 等待状态
5. timeWaiting 超时等待状态
6. Terminated 终止状态。

## 13、线程死锁的四大条件 ##
1. 互斥条件：一个资源同一时间内只能被一个线程所占用
2. 请求与保持条件：一个线程在请求某个资源而阻塞时，对已经获取的资源不会释放
3. 不剥夺条件：某个线程获取的资源，被能被其他线程强行剥夺，只能由自己释放
4. 循环等待：多个线程和资源之间形成首尾相连的请求和依赖关系

## 14、wait方法和sleep方法的区别
 - wait方法释放锁，sleep方法不会
 - wait用于线程间通信，sleep用于暂停执行
 - wait方法线程不会主动苏醒，需要系统调用notify方法或者notifyAll，sleep可以，wait（long）可以
 - sleep是Thread的静态方法，wait是Object中定义的方法。
	
## 15、volatile关键词
1. 保证变量的可见性 
2. 禁止指令重排序。 （new 对象 1、给对象分配内存空间 2、初始化 3、将对象直线引用地址）


## 16、悲观锁和乐观锁
 - 悲观锁：以最坏的情况考虑问题，每次访问资源的时候都有可能产生问题，每次访问资源都需要进行锁操作
 - 乐观锁：以最好的情况考虑问题，每次访问的时候不会存在问题，只有在提交修改的时候去验证，资源是否已经被其他资源修改过了。

## 17、实现乐观锁：1、版本号机制 2、CAS算法。

## 18、CAS算法怎么实现的。
 - 1、E 一个预期值
 - 2、V 要更新的变量值
 - 3、N 拟写入的新值

## 19、synchronized关键词：保证同一个时间内，是有一个线程能够访问代码块或者方法
 - 1、修饰实例方法（锁当前对象）
 - 2、修饰静态方法（锁当前类）
 - 3、修饰代码块（？？任意）

## 20、synchronized和reenTrantLock区别和共同点
 - 1、都是可重入锁
 - 2、reenTrantLock可以实现公平锁
 - 3、reenTrantLock的高级功能：
     - 等待可中断 
	 - 可实现公平锁 
     - 可实现选择性通知。需要借助于Condition接口和newCondition()方法 
  - 4、synchronized依赖于JVM，而reenTrantLock依赖于API

## 21、ThreadLocal
 - 每个Thread拥有一个threadLocalMap类存储 。key是ThreadLocal变量，而value是值。 key是弱引用，value是强引用。

## 22、线程池的好处
 - 1、降低资源消耗 
 - 2、提高响应速度
 - 3、提高线程的可管理性

## 23、线程池的参数 ##
1. coolPoolSize：任务队列未达到队列容量是，最大可同时运行的线程数量
2. maxPoolSize：任务队列达到队列容量时候，最大可同时运行的线程数量
3. workQueue：判断当前同时运行的线程数量是否达到了核心线程数，如果达到了，则将任务存放在该队列中。
4. keepAliveTime：
5. unit
6. ThreadFactory
7. handle：拒绝策略

## 24、JMM java内存模型：抽象了线程和主内存之间的关系。
 - JMM是什么：Java定义的并发编程的一组规范，除了抽象线程和主内存之间的关系之外，其还规定了从Java代码到CPU可执行命令的这个转换过程要遵守哪些和并发相关的原则和规范。
 - 主内存：所有线程创建的实例对象都存放在主内存中，不管是实例对象的成员变量还是方法中的局部变量
 - 本地内存：每个线程都有一个私有的本地内存来保存共享变量的副本。每个线程都有自己的本地内存，无法访问其他线程的本地内存。


## 25、happen-before原则：
 - 为了对编译器和处理器的约束尽可能少，只要不改变程序执行结果，编译器和处理起怎么进行重新排序优化都行。 
 - 对于改变程序执行结果的重排序，JMM要求编译器和处理器都禁止这种重排序。
 - happen-before八大原则：
	- 1、程序次序规则：在一个线程内，按照控制流程，书写在前面的操作先行发生在发生在后面的操作。
	- 2、管制锁定规则：一个unlock操作先行发生于后面的锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。
	- 3、volatile 变量规则：对于一个volatile修饰的变量的写操作优先于发生于后面对这个变量的读操作。
	- 4、线程启动规则：Thread对象的start方法发生于此线程的每个动作之前。
	- 5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测。
	- 6、线程中断规则：对线程的interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。通过interrupted()方法检测是否有中断发生。
	- 7、对象终结规则：一个对象的初始化完成先行于他的finalize()方法。
	- 8、传递性：如果A先行发生于B，B先行发生于C，那么就可以得到A先行发生于C的结论。
 -  as-if-serial：不管怎么重新排序，单线程环境下的执行结果不能改变。


## 26、并发编程的三个特性：
 - 原子性 
 - 可见性
 - 有序性

## 27、常见的IO模型
 - 1. BIO 同步阻塞 ：同步阻塞模型中，应用程序发起read调用后，会一直阻塞，直到内核数据拷贝到用户空间。
 - 2. NIO none-blocking IO /NEW-IO？？非阻塞同步？？（可以看作是IO多路复用模型）：NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO
	 - NIO采用通道和缓冲去对文件进行操作，以及用socketChannel和ServerSocketChannel进行网络传输。
	 - 传统的IO采用阻塞式模型，对于每个连接，都需要创建一个独立的线程来处理读写操。当一个线程等待IO操作时，无法执行其他任务。会导致大量的线程创建和销毁，以及上下文切换，降低了系统性能。NIO使用IO多路复用模型，允许线程在等待IO时执行其他任务。这种模式通过选择器（Selector）来监控多个通道（Channel）上的I/O事件，实现了更高的性能和可伸缩性。	
 - 3. AIO(NIO2) 异步非阻塞的IO。异步IO是基于事件和回调机制实现的，也就是应用操作之后不会直接返回，不会阻塞那里，当后台处理完成之后，操作系统会通知相应的线程进行后续的操作。
 - 4. IO和NIO的区别：
	- 可以简单认为IO是面向流的，NIO是面向块的。（缓冲区）处理
	- 面向流的I/O系统一次一个字节的处理数据
	- 面向块的I/O系统以块的形式处理数据。
	
## 28、IO
 - IO即Input/Output，输入和输出。数据输入到计算机内存的过程即输入，计算机内存输出到外部存储（比如数据库、文件、远程主机）的过程即输出。
 - IO流在Java中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。
 - Java的IO是从四类基础类中派生出来的：
	- InputStream/Reader：所有的输入流的基类，前者是字节字节流，后者是字符输入流。
	- OutputStream/Writer：所有的输出流的基类，前者是字节流，后者是字符流。
 - 缓冲流：
	- 字节缓冲流：IO操作是很消耗内存的，缓冲流将数据加载到缓冲去，一次性读取/写入多个字节，从而避免频繁的IO操作，从而提高流的传输效率。字节缓冲流通过装饰器模式增加（InputStream/OutPutStream）子类对象的功能。 
	- 字符缓冲流：类似于字节缓冲流，内部都维护一个字节数组作为缓冲。字符缓冲流主要用来操作字符。

## 29、JavaIO的设计模式
1. 装饰器模式
 - 装饰器模式：可以在改变原有对象的基础上，增强器功能。
 - 对于字节流来说，FilterInputStream 和FilterOutputStream是装饰器模式的核心，分别用于增加InputStream和OutputStream子类对象的功能。
2. 适配器模式 
	- 适配器模式：主要用于互补兼容的接口的协调工作。
	- 适配者：适配者模式中被适配的对象称之为适配者，作用于适配者之间的被称为适配器。
	- 适配器：适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。		
3. 工厂模式：NIO中。
4. 观察者模式：NIO中的文件监听属于观察者模式。

## 29、类加载过程
 - 加载：
   	- 1、通过全类名获取定义此类的二进制字节流。
    - 2、将字节流所代表的静态储存结构转换为方法区的运行时数据结构。
	- 3、在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。 
 - 验证：
   	- 1、文件格式验证（Class文件格式检查）
    - 2、元数据验证（字节码语义检查）
	- 3、字节码验证（程序语义检查）
	- 4、符号引用验证 （类的正确性检查）
 - 准备： 准备阶段是正式为类变量分配内存并设置初始值的阶段。	这些内存都在方法区中分配。
   - 1. 这些类变量只包括类的静态成员变量，而不包括实例变量。
   - 2. 字符串变量在1.7之后被移动放在堆中。
   - 3. 这里的初始值通常情况下指的是数据类型的零值。
 - 解析：解析接待是程序将常量池内的符号引用替换为直接引用的过程。解析动作主要针对 类或、接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符等7种符号引用。
 - 初始化：是执行类初始化方法的<clinit> ()方法的过程，是类加载的最后一步。这一步JVM才真正开始执行类中定义的Java程序代码。

##30、类卸载：即Class对象被GC
 - 三个必要条件:
	- 该类的所有对象是实例被回收。
	- 该类没有在其他地方被引用。	
	- 该类的类加载器被GC。

##31、Java堆空间和内存回收原则
1. 堆空间的基本结构
 - 新生代
 - 老年代
 - 永久带(Java1.8之后用元空间取代)

2. 内存分配和回收原则
	- 对象首先在Eden区分配
	- 大对象直接进入老年代（需要大量连续内存空间的对象，例如：字符串、数组等）
	- 长期存活的对象进入老年带
	
3. 死亡对象的判断
	- 引用计数法：给对象添加一个引用计数器	
	  	- 每当有一个地方引用对象，计数器就加1.
	    - 当引用失效，计数器就减少1
		- 任何时候计数器为0的对象就是不可能再被使用的。 
		- 这个方法实现简单，效率高，但是目前虚拟机中没有选择这个算法管理内存，因为它很难解决对象之间循环引用的问题。
	- 可达性分析算法：这个算法的基本思路就是通过一系列称为“GC Roots”的对象作为起点，从这些起点开始向下搜索，节点所走过的路径被称为引用链，当一个对象到GC-Roots没有任何引用链的话，则证明此对象是不可用的，需要被回收
4. 垃圾收集算法：
	- 标记-清除算法：标记清除算法，分为标记和清除两个阶段，首先标记可达对象，然后清除
		- 问题：1、效率：标记和清除效率都不高 2、空间问题：会产生很多不连续的空间
	- 复制算法：可以将内存分为大小相同的两块，每次使用其中的一块，当这一块使用完成之后，就将存活的对象复制到另一块去，然后把使用的空间一次清理。
	- 标记-整理算法：
	- 分代收集算法

redis内存淘汰机制
	1、从设置了过期时间的数据中，选取最少使用的数据淘汰
	2、从设置了过期时间的数据中，选取即将过期的数据
	3、从设置了过期时间的数据中，随机淘汰数据
	4、从所有数据中，淘汰最少使用的数据
	5、从所有数据中，随机淘汰数据
	6、禁止驱逐数据，当内存不足时，插入新数据直接报错。
	
	
	redis4新增的特性
	1、从设置了过期时间的数据中，淘汰最不经常使用的
	2、从所有数据中，选取最不经常使用的数据
	
	Reds产生的问题
		1、缓存穿透
			查询根本不存在的数据	
				解决办法：
					（1）数据范围
				 	eg邮箱格式
					eg主键不小于0
					（2）过滤器
					
		2、缓存击穿：访问热点数据，但是数据在缓存中不存在。（可能是批量过期了，导致数据库的访问量激增）
		解决办法：
			热点数据时间比较久，永久不过期
			数据预热
			请求数据库写缓存之前，先获取互斥锁，保证同一个时间内只有一个请求落到数据库。
		3、大量的缓存数据失效。
			解决办法
		3、缓存雪崩
		
	Redis数据和数据库数据一致性问题。





































