## 4、Redis ##
### 4.1Redis的数据类型
1. String k/v
2. List
3. Set
4. ZSet
5. Hash

### 4.2  Redis的3种常用的读写策略。
- 1、Cache Aside Pattern 旁路缓存模式
    - 读：
        - 1、从cache种读取数据，如果缓存种有数据的直接返回。
        - 2、cache中读取不到的话，就从db中获取数据返回
        - 3、再把数据放到cache中.
    - 写：
        - 1、先更新DB
        - 2、然后直接删除cache。
    - 旁路缓存模式缺陷：
        - 1. 首次请求的数据在cache中不存在，
        - 2. 写操作比较频繁的话，会导致缓存中的数据频繁被删除，会影响缓存命中率。
    - 解决办法：
        - 数据库强一致性场景：更新db的时候同样更新cache，不过我们需要加一个锁/分布式锁来抱保证更新cache的时候不存在线程安全问题。
        - 可以短暂的允许数据库和缓存不一致的场景：更新DB的时候同时更新cache，但是给换粗加一个比较短的过期时间。

- 2、 Read/Write Through Pattern（读写穿透）
    - 读:
        - 1、从cache中读取数据，如果缓存中存在数据的话直接返回数据
        - 2、如果cache中没有数据的话，先db加载，写入到cache中后返回响应。
    - 写
        - 1、先查cache，cache中不存在，直接更新db。
        - 2、cache中存在，则先更新cache，然后cache服务自己更新DB（同步更新cache和db）。
    - 读写穿透的缺陷：

- 3、Write Behind Pattern（异步缓存写入
    - 这种方式和读写穿透的方式很相似。 两者都是有cache服务来负责cache和db读写。但是两者又有很大的不同，读写穿透是同步更细cache和db，而Write Behind则是只是更新缓，不直接更新DB，而是改为异步批量的方式更新DB

### 4.3 如何保证Redis和数据库的一致性。
1. 更新缓存数据的4种方案。ccc
    - 先更新缓存，再更新数据库
    - 先更数据库，再更新缓存
    - 先淘汰数据，再更新数据库
    - 先更新数据库，再淘汰数据

2. 更新、淘汰数据优缺点。
    - 淘汰数据
        - 优点：操作方式简单。
        - 缺点：淘汰数据后，下一次无法在缓存中查询到，会有一次cache-miss。
    - 更新数据
        - 优点：缓存命中率高，不会造成cache-miss。
        - 缺点：1、 更新cache消耗更大。 2、并发更新到处数据不一致问题。

3. 保持数据一致性的策略。
    1. 延时双删：(1)写请求 (2)删除缓存 (3)更新数据库 (4)休眠一会，再次删除缓存。
    2. 删除缓存重试机制：
        - 写请求更新数据库
        - 缓存因为某些原因删除失败
        - 把删除的Key放入消息队列。
        - 要删除的key拉出来。
        - 重试删除操作。
    3. 读取数据库的binlog日志来异步淘汰缓存。

4. 保证本地缓存和分布式缓存的一致性。
    1. 可以使用Redis本身的Pub/Sub机制，分布式集群的所有节点都订阅删除本地缓存频道。删除Redis的节点，同时发布删除本地缓存消。
    2. 引入专业的消息队列，保证消息的可靠性，但是增加了系统的复杂性。
    3. 设置适当的过期时间兜底，本地缓存可以设置相对短一点的过期时间。

### 4.4 Redis分区方案
1. 节点取余
2. 一致性Hash分区，
3. 虚拟槽分区

### 4.5 Redis集群
1. redis集群的三种模式
    - 1. 主从模式
    1. 集群介绍
        - (1)主从模式里使用一个redis实例作为主机，其余多个实例作为备份机（slave）
        - (2)master用来支持数据的写入和读取操作，而slave节点支持读取以及master的数据同步
        - (3)在整个架构中，master和slave实例里的数据完全一致。
        2. 主从复制原理：
        - 全量同步:
            - 1、当从节点启动时，向主节点发送SYNC消息，
            - 2、主节点收到SYNC命令后，开始在后台执行保存快照的命令生成RDB文件，使用缓冲记录此后执行的所有命令。
            - 3、主节点快照完成后，将快照文件和所有缓存命令发送给集群内的从节点，并在发送期间继续记录被执行的命令。
            - 4、主节点快照发送完成后向从节点发送所缓冲区的命令。
            - 5、从节点载入快照文件后，开始接受命令请求，执行收到的主节点缓冲区的写命令。
            - 增量同步:
                - 主从复制中因为网络原因造成数据丢失的场景，当从节点再次连接主节点。如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效的避免全量复制的过高开销。
        3. 主节点故障的处理方式：
            - 主从模式中，每个客户端连接redis实例都指定了ip和端口号。如果连接的redis实例因为故障下线了，则无法通知客户端连接其他客户端，因此只能手动操作。
        4. 不支持高可用
    - 2. 哨兵模式
        1. 集群介绍：和主从模式不一样的是，哨兵模式中增加了独立进程（即哨兵）来监控集群的一举一动。客户端在连接集群时，首先连接哨兵，通过哨兵查询主节点的地址，然后再去连接主节点信息进行数据交互。如果master异常，则会进行master-slave切换，将最优的一个slave切换为主节点。同时，哨兵持续监控挂掉的节点，待其恢复后，作为新的节点假如集群中。
        2. 主节点故障处理方式/哨兵工作方式：
            - 1、每个哨兵每秒向集群中的master、slave以及其他哨兵发送一个Ping命令。
        - 2、如果某个实例距离最后一次有效回复ping命令的时间超过一定的值，则会被标记为下线。
        - 3、如果master被标记为主观下线，那么正在监视master的哨兵以每秒的频率确认其确实进入主观下线状态，且数量达到一定值时，master会被标记为下线，然后通知其他的服务器，修改配置文件，让他们切换主机。
        - 4、客户端在master节点发生故障时会向哨兵要地址，此时会获得最新的master节点地址。
        3. 扩容问题：哨兵模式的出现虽然解决了主从模式中master节点宕机不能自动切换的问题(即高可用)的问题。但是，随着业务的逐渐增长，不可避免需要对当前业务进行扩容。
        - 1、垂直扩容：通过增加master来增加容量
        - 2、水平扩容：通过增加节点来进行扩容，即在当前基础上再增加一个master节点。
            - 虽然垂直扩容方式很便捷，不需要添加多余的节点，但是机器的容量是有限的，最终还是需要通过水平扩容方式来解决。而水平扩容涉及到数据的迁移，且迁移过程中又要保证服务的可用性。因此，数据能不迁移，尽量不迁移。
            - 显然哨兵模式无法满足这种情形，因此redis-cluster应运而生。
    - 3. Redis-cluster模式
        1. 集群介绍：
            1. redis-cluster模式采用了无中心节点的方式来实现，每个主节点都会与其他节点保持连接。节点间通过gossip协议交换彼此的信息。同时每个主节点又有一个或者多个从节点。
            2. 客户端连接集群时，直接与redis集群的每个主节点连接，根据hash算法取模key存储在不同的hash槽上。
            3. 在集群中采用数据分片的方式，将redis集群分为16384个哈希槽。 这些哈希槽分别存储于三个主节点中。
                - master1负责 0-5460号哈希槽。
                - master2负责 5461-10922哈希槽。
                - master3负责 10922-16383哈希槽。
            4. 每个节点会保存一份数据分布表，节点将自己的slot信息发送到其他节点，节点间不停地传递数据分布表。
            5. 客户端连接集群时，通过集群的某个节点地址进行连接。客户端尝试向这个节点执行命令时，比如获取某个key值，如果key所在的slot刚好在该节点上，则能够直接执行成功。如果slot不在该节点，则节点返回MOVED错误，同时把该slot对应的节点告诉客户端，客户端可以去该节点执行命令。
        - 2. 主节点故障处理方式：
        1. Redis cluster中主节点故障处理方式与哨兵模式比较相像，当约定的时间内某节点无法与集群中的另一个节点顺利完成Ping消息通信时，则将该节点标记为主观下线状态，同时将这个消息向整个集群广播。如果一个节点收到某个节点失联的数量达到了集群的大多数时，那么将该节点标记为客观下线状态，并向集群广播下线节点fail消息。然后立即对该故障节点进行主从切换、等到原来的节点恢复后，会自动成为新主节点的从节点。如果主节点没有从节点，那么当他发生故障时，集群就将处于不可用状态、
        - 3. 扩容问题：
        1. 当集群中加入新节点时，会与集群中的某个节点进行握手，该节点会把集群内的其他节点信息通过gossip协议发送给新节点，新节点与这些节点完成握手后加入到集群中。 然后集群中的节点会各自取一部分哈希槽分配给新节点。当集群要删除节点时，只需要将节点中的所有哈希槽移动到其他节点，然后再移除空白的节点就可以了。
    

