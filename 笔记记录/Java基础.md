## Java SPI机制 ##
1. Server Provider Interface 服务提供者的接口
	例如： SLF4J（Simple Logging Facade for Java）是 Java 的一个日志门面（接口）
	实现有 LogBack,Log4j Log4j2 

## 1、Java对象的内存布局是什么样子的。
1. 对象头 MarkWord和ClassPointer部分
	1. MarkWord部分记录了一些列的标记为。比如偏向锁、GC信息等。
	2. ClassPointer记录了对象的内存地址信息。
2. Length：数组长度
3. instance data /Array instance 数组对象信息
4. Padding 填充部分、

## 2、泛型和泛型擦除 ##
1. 泛型：类型参数化。把类型明确的工作推迟到对象创建或者调佣方法的时候才去明确的特殊类型。
2. 泛型擦除： 泛型只在编译器中实现而非虚拟机中实现，所以要在虚拟机中进行泛型擦除。也就是说在编译阶段使用泛型，而在运行阶段进行擦除。
3. 泛型的作用
   1. 第一个是泛化。
   2. 第二个是类安全性。
   3. 第三是消除了强制类型转换，减少了出错的机会。
   4. 向后兼容。 
4. 泛型的好处
   1. 类安全性。编译器会帮助验证类型假设
   2. 消除了强制类型转换。
   3. 更高的运行效率。
   4. 潜在的性能收益：泛型为较大的优化带来可能。
 


## 3、封装
1. 设置属性不可以被外部访问，但提供修改和查询属性的方法。
2. 的行为和属性看成不可分割的一部分。


## 4、继承
1. 子类拥有父类的属性和方法。
2. 可以操作父类的私有属性，不能访问私有方法。可以重写父类的方法


## 5、多态
 - 一个行为可以具有多个变现形式的能力。。
1. 方载和对象多态两种形式的多态。
2.	方法重载：指的是，一个类中可以有相同名称的方法名。但入参的类型或者顺序不同。返回类型也可以不同。完成不同的功能。
3. 父类的引用指向子类的实例
	
		1、子类需要继承某个类，或者实现某个接口
	
		2、调用了哪个方法，需要在程序运行时才能确定
	
		3、不能调用在在父类中未定义的方法
	
	    4、子类实现了父类的方法，则实际调用的是子类方法，否则调用的是父类的方法

## 抽象类和接口的区别

1. 都可以用抽象方法。
2. 都可以有默认的实现方法。
3. 都不能被实例化


## 不同
1. 接口是对类行为的定义，或者只是一个表示，用于定义类有那些行为，实现类必须实现这些行为。而抽象类一般用于代码复用
2. 一个类可以实现多个接口但只能继承一个类。
3. 接口的成员变量是public static final类型的，且必须有初始值。而抽象类成员变量默认是defaule，可以在子类重新定义，也可以重新赋值。


## 进程和线程
1. 进程：

	进程：程序的一次执行过程，系统运行程序的基本单位。
	
	线程：和进程类似，是比进程更小的运行单位，一个进程运行时可以有多个线程。不同的是，进程可以共享队和方法区，且有自己私有的空间，

程序计数器：

	记录字节码指令的行号。字节码解释器，通过改变程序计数器来一次读取指令。从而达到控制代码流程的作用。顺序执行、选择、循环、异常捕获等。

  第二个是，多线程运行时，记录下线程当前运行到的指令位置，下一次线程切换回来的时候能够继续执行。

虚拟机栈：操作数栈、局部变量表、常量池引用信息等

堆，存放对象

方法区： 类信息、常量、静态变量



多线程好处：

提高单个cpu和IO系统的效率；多核时代：充分利用多核cpu的能力

不好：线程不安全问题、内存泄漏、死锁

线程不安全问题：

	同一份数据，是否保证数据的正确性和一致性。是否有数据混乱、错误或者丢失。

## 线程的状态 ##

1. NEW
2. Runnable状态，调用start ，等待运行状态。 ready状态，获取cpu时间片后就是running状态。
3. Blocking 阻塞状态
4. WAITING 等待状态
5. timeWating 超时等待状态
6. Terminated 终止状态。





## 线程死锁的四大条件 ##

1. 互斥条件：一个资源同一时间内只能被一个线程所占用，
	
2. 请求与保持条件：一个线程在请求某个资源而阻塞时，对已经获取的资源不会释放，
	
3. 不剥夺条件：某个线程获取的资源，被能被其他线程强行剥夺，只能由自己释放

4. 循环等待：多个线程和资源之间形成首尾相连的请求和依赖关系。





wait方法和sleep方法的区别

	wait方法释放锁，sleep方法不会
	
	wait用于线程间通信，sleep用于暂停执行
	
	wait方法不会主动苏醒，需要系统调用notify方法或者notifyall，sleep可以，wait（long）可以
	
	sleep是Thread的静态方法，wait是Object中定义的方法。
	
	volatile
	
		1、保证变量的可见性
	
	    2、禁止指令重排序。
	
			（new 对象 1、给对象分配内存空间 2、初始化 3、将对象直线引用地址）


​			



悲观锁：以最坏的情况考虑问题，每次访问资源的时候都有可能产生问题，每次访问资源都需要进行锁操作

乐观锁：以最好的情况考虑问题，每次访问的时候不会存在问题，只有在提交修改的时候去验证，资源是否已经被其他资源修改过了。



实现乐观锁：1、版本号机制 2、CAS算法。

CAS算法怎么实现的。

1、E 一个预期值

2、V 要更新的变量值

3、N 拟写入的新值



synchronized 

	保证同一个时间内，是有一个线程能够访问代码块或者方法

1、修饰实例方法（锁当前对象）

2、修饰静态方法（锁当前类）

3、修饰代码块（？？任意）

synchronized和reentrantlock

1、都是可重入锁

2、reentrantlock可以实现公平锁

3、reentrantlock的高级功能	

		等待可中断
	
		可实现公平锁
	
	     可实现选择性通知。需要借助于Condition接口和newCondition()方法



ThreadLocal

	每个Thread拥有一个threadlocalMap类存储 。key是ThreadLocal变量，而value是值。 key是弱引用，value是强引用。

线程池的好处

	1、降低资源消耗，
	
	2、提高响应速度
	
	3、提高线程的可管理性



## 线程池的参数 ##
1. coolpool size：任务队列未达到队列容量是，最大可同时运行的线程数量

2. maxpoolsize：任务队列达到队列容量时候，最大可同时运行的线程数量

3. workQueue：判断当前同时运行的线程数量是否达到了核心线程数，如果达到了，则将任务存放在该队列中。

4. keepAliveTime：

5. unit

6. ThreadFactory

7. handle：拒绝策略



JMM java内存模型：抽象了线程和主内存之间的关系。

1. JVM ：java内存结构
	2. 堆、方法区 ；程序计数器、虚拟机栈、本地方法栈
	3.  





主内存：所有线程创建的实例对象都存放在主内存中，不管是实例对象的成员变量还是方法中的局部变量

本地内存：每个线程都有一个私有的本地内存来保存共享变量的副本。每个线程都有自己的本地内存，无法访问其他线程的本地内存。



happen-before原则：

	为了对编译器和处理器的约束尽可能少，只要不改变程序执行结果，编译器和处理起怎么进行重新排序优化都行，

   对于改变程序执行结果的重排序，JMM要求编译器和处理器都禁止这种重排序。



并发编程的三个特性：

	原子性
	
	可见性
	
	有序性


常见的IO模型
1. BIO 同步阻塞
2. NIO none-blocking IO /NEW-IO
3. AIO(NIO2)

类加载过程
	加载：读取类的二进制流信息到内存值，生成一个可以访问的Class对象
	验证：
	准备
	解析
	初始化



redis内存淘汰机制
	1、从设置了过期时间的数据中，选取最少使用的数据淘汰
	2、从设置了过期时间的数据中，选取即将过期的数据
	3、从设置了过期时间的数据中，随机淘汰数据
	4、从所有数据中，淘汰最少使用的数据
	5、从所有数据中，随机淘汰数据
	6、禁止驱逐数据，当内存不足时，插入新数据直接报错。
	
	
	redis4新增的特性
	1、从设置了过期时间的数据中，淘汰最不经常使用的
	2、从所有数据中，选取最不经常使用的数据
	
	Reds产生的问题
		1、缓存穿透
			查询根本不存在的数据	
				解决办法：
					（1）数据范围
					eg邮箱格式
					eg主键不小于0
					（2）过滤器
					
		2、缓存击穿：访问热点数据，但是数据在缓存中不存在。（可能是批量过期了，导致数据库的访问量激增）
		解决办法：
			热点数据时间比较久，永久不过期
			数据预热
			请求数据库写缓存之前，先获取互斥锁，保证同一个时间内只有一个请求落到数据库。
		3、大量的缓存数据失效。
			解决办法
		3、缓存雪崩
		
	Redis数据和数据库数据一致性问题。


​	
	Redis三种常用的读写策略。
		？？？


OSI七层模型
应用层
表示层
会话层
传输层
网络层
数据链路成
物理层


TCP/IP 协议
	1、SYN：同步标识位
	2、SCK：确认标识位
	3、FIN 完成标识位
	4、PSH：推送标识位

	3次握手
	1、客户端先发送带有SYN（SEQ=x）标识的数据包给服务端，然后服务端进入SYN-send状态，等待服务器的确认
	2、服务端根据数据包返回SYN+ACK数据包（SEQ=y，ACK=x+1），服务端进入SYS——RECV状态
	3、客户端收到信息后，发送带有ACK的数据包（ACK=y+1）-》服务端，然后服务端和客户端都进入ESTABLISHED状态，完成TCP三次握手。
		
	四次挥手：
	1、客户端发送一个FIN（SEQ=x）的数据，进入FIN-WAIT-1状态
	2、服务端发送一个ACK（x+1）的数据，此时客户端进入FIN-WAIT-2状态，服务端进入CLOSE-WAIT状态。
	3、服务端关闭与客户端的连接，并发送一个FIN（y）数据=》客户端请求关闭连接，服务端进入LAST——ACK状态
	4、客户端发送一个ACK（y+1）标识的数据包=》服务端，并进入TIME-WAIT状态，服务端收到数据后没进入CLOSE状态，此时，如果客户端等待2MSL后任然没有回复，就证明服务端已经正常关闭，客户端也就可以关闭连接。


 	
 	
 	
 	HTTPS
 		非对称加密：交换密钥。
 		对称加密：加密数据。
 	公钥传输的信赖性：
 		数字签名
 		证书：证书颁发结构（CA）


​	
	HTTP状态码
	1XX：信息性状态码（接受的请求正在处理）
	2XX：成功状体码。请求处理完毕
	3XX：重定向状态码。 301 资源被永久重定向 302：资源被临时重定向了。
	4XX：客户端错误状态码：服务器无法完成请求。 400BadRequest：参数不合理，请求方法错误。   401:未认证却请求可需要认证的资源 403:直接拒绝http请求，不处理，一般用来针对非法请求 。 404：你请求的资源在服务器为找到。
	 409:Conflict：表示请求的资源与服务器当前的状态存在冲突，请求无法被处理。
	
	5XX：服务器错误状态码：服务器处理请求出错。
		500:服务端出问题了。比如程序报错了，但未处理错误。
		502:Bad Gateway：我们的请求到服务端了，但是服务端响应的却是一个错误的响应，


# springBean的生命周期 #
四个阶段
1. 实例化
2. 属性赋值
3. 初始化
	1. 
4. 销毁
​		
​		
​		





































