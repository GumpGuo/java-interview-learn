# 一、Java基础 
## 1、Java SPI机制 ##
1. Server Provider Interface 服务提供者的接口
   例如： SLF4J（Simple Logging Facade for Java）是 Java 的一个日志门面（接口）
   实现有 LogBack,Log4j Log4j2

## 2、Java对象的内存布局是什么样子的。
1. 对象头 MarkWord和ClassPointer部分
    1. MarkWord部分记录了一些列的标记为。比如偏向锁、GC信息等。
    2. ClassPointer记录了对象的内存地址信息。
2. Length：数组长度
3. instance data /Array instance 数组对象信息
4. Padding 填充部分、

## 3、泛型和泛型擦除 ##
1. 泛型：类型参数化。把类型明确的工作推迟到对象创建或者调佣方法的时候才去明确的特殊类型。
2. 泛型擦除： 泛型只在编译器中实现而非虚拟机中实现，所以要在虚拟机中进行泛型擦除。也就是说在编译阶段使用泛型，而在运行阶段进行擦除。
3. 泛型的作用
    1. 第一个是泛化。
    2. 第二个是类安全性。
    3. 第三是消除了强制类型转换，减少了出错的机会。
    4. 向后兼容。
4. 泛型的好处
    1. 类安全性。编译器会帮助验证类型假设
    2. 消除了强制类型转换。
    3. 更高的运行效率。
    4. 潜在的性能收益：泛型为较大的优化带来可能。

##4、Java的三大特性
- 封装
    - 1、设置属性不可以被外部访问，但提供修改和属性值的方法。
    - 2、类的行为和属性看看成是不可分割的一部分。
- 继承
    - 1、子类可以拥有父类的属性和方法。
    - 2、可以操作父类的私有属性，但不能访问私有方法。可以重写父类的方法。
- 多态
    - 一个行为可以具有多个多个表现形式或者形态的能力
    - 方法重载和对象多态两种形式的多态。
        - 1、方法重载：指的是，一个类中可以有相同名称的方法。但入参的类型或者顺序不同。返回类型也可以不同，完成不同的功能。
        - 2、对象多态：父类的引用实现子类的实例。
    - 多态的特点：
        - 1、必须要子类继承某个类。
        - 2、调用了哪个方法，需要在程序运行时才能确定。
        - 3、不能调用在父类中未定义的方法。
        - 4、子类实现了父类的方法，则调用的实际是子类方法，否则调用的是父类的方法。
    - 多态的必要条件
        - 集成
        - 重载
        - 父类的引用指向子类的实例

## 5、Java创建对象的几种方式
- 1、new关键词。
- 2、Class类的newInstance方法。
- 3、构造方法类的newInstance方法。 .class.getCon
- 4、使用clone方法。
- 5、使用反序列化。ObjectInputStream

##6、Object中有哪些方法？
- getClass
- hashCode
- equals
- toString
- clone
- notify
- notifyAll
- wait()
- wait(long timeout)
- wait(long timeout,long nanos)
- finalize()

##7、Java反射以及优缺点
- Java反射：可以通过反射获取类的所有属性和方法，并执任意一个类的属性和方法。
- 优缺点：
    - 优点：让代码更加灵活，为各种框架提供了便利。
    - 缺点：增加了安全问题：无视泛型参数的安全检查。反射的性能也比较差。

##8、何谓注解。
- 用于修饰类、方法、变量。在程序编译期间或者运行期间提供某些信息。
- 编译器直接扫描：eg@Override 。运行期间通过发射获取。


##9、抽象类和接口的区别
- 相同点
1. 都可以用抽象方法。
2. 都可以有默认的实现方法。
3. 都不能被实例化
-  不同点
1. 接口是对类行为的定义，或者只是一个表示，用于定义类有那些行为，实现类必须实现这些行为。而抽象类一般用于代码复用
2. 一个类可以实现多个接口但只能继承一个类。
3. 接口的成员变量是public static final类型的，且必须有初始值。而抽象类成员变量默认是defaule，可以在子类重新定义，也可以重新赋值。


## 10、进程和线程
1. 进程：
   进程：程序的一次执行过程，系统运行程序的基本单位。
   线程：和进程类似，是比进程更小的运行单位，一个进程运行时可以有多个线程。不同的是，进程可以共享队和方法区，且有自己私有的空间，

## 10、 JVM虚拟机
1. JVM内存分区
    - 程序计数器：可以看作是当前程序所执行的字节码的行号指示器。
        - 1、记录字节码指令的行号。字节码解释器，通过改变程序计数器来一次读取指令。从而达到控制代码流程的作用。顺序执行、选择、循环、异常捕获等。
        - 2、多线程运行时，记录下当前运行到的指令为止，下一次线程切换回来的时候能够继续运行。
    - 虚拟机栈：操作数栈、局部变量表、动态链接、方法返回地址。
    - 本地方法栈：
    - 堆 ：存放对象
    - 方法区 ：类信息、常量、静态变量

## 11、多线程的优点和缺点
- 优点：提高单个cpu和IO系统的效率；多核时代：充分利用多核cpu的能力。
- 缺点：线程不安全问题、内存泄露、死锁。
- 线程不安全问题：同一份数据，是否报数据正确性和一致性。是否有数据混乱、错误或者丢失。

##  12、 线程的状态 ##
1. NEW
2. Runnable状态，调用start ，等待运行状态。 ready状态，获取cpu时间片后就是running状态。
3. Blocking 阻塞状态
4. WAITING 等待状态
5. timeWaiting 超时等待状态
6. Terminated 终止状态。

## 13、线程死锁的四大条件 ##
1. 互斥条件：一个资源同一时间内只能被一个线程所占用
2. 请求与保持条件：一个线程在请求某个资源而阻塞时，对已经获取的资源不会释放
3. 不剥夺条件：某个线程获取的资源，被能被其他线程强行剥夺，只能由自己释放
4. 循环等待：多个线程和资源之间形成首尾相连的请求和依赖关系

## 14、wait方法和sleep方法的区别
- wait方法释放锁，sleep方法不会
- wait用于线程间通信，sleep用于暂停执行
- wait方法线程不会主动苏醒，需要系统调用notify方法或者notifyAll，sleep可以，wait（long）可以
- sleep是Thread的静态方法，wait是Object中定义的方法。

## 15、volatile关键词
1. 保证变量的可见性
2. 禁止指令重排序。 （new 对象 1、给对象分配内存空间 2、初始化 3、将对象直线引用地址）


## 16、悲观锁和乐观锁
- 悲观锁：以最坏的情况考虑问题，每次访问资源的时候都有可能产生问题，每次访问资源都需要进行锁操作
- 乐观锁：以最好的情况考虑问题，每次访问的时候不会存在问题，只有在提交修改的时候去验证，资源是否已经被其他资源修改过了。

## 17、实现乐观锁：1、版本号机制 2、CAS算法。

## 18、CAS算法怎么实现的。
- 1、E 一个预期值
- 2、V 要更新的变量值
- 3、N 拟写入的新值

## 19、synchronized关键词：保证同一个时间内，是有一个线程能够访问代码块或者方法
- 1、修饰实例方法（锁当前对象）
- 2、修饰静态方法（锁当前类）
- 3、修饰代码块（？？任意）

## 20、synchronized和reenTrantLock区别和共同点
- 1、都是可重入锁
- 2、reenTrantLock可以实现公平锁
- 3、reenTrantLock的高级功能：
    - 等待可中断
    - 可实现公平锁
    - 可实现选择性通知。需要借助于Condition接口和newCondition()方法
- 4、synchronized依赖于JVM，而reenTrantLock依赖于API

## 21、ThreadLocal
- 每个Thread拥有一个threadLocalMap类存储 。key是ThreadLocal变量，而value是值。 key是弱引用，value是强引用。

## 22、线程池的好处
- 1、降低资源消耗
- 2、提高响应速度
- 3、提高线程的可管理性

## 23、线程池的参数 ##
1. coolPoolSize：任务队列未达到队列容量是，最大可同时运行的线程数量
2. maxPoolSize：任务队列达到队列容量时候，最大可同时运行的线程数量
3. workQueue：判断当前同时运行的线程数量是否达到了核心线程数，如果达到了，则将任务存放在该队列中。
4. keepAliveTime：
5. unit
6. ThreadFactory
7. handle：拒绝策略

## 24、JMM java内存模型：抽象了线程和主内存之间的关系。
- JMM是什么：Java定义的并发编程的一组规范，除了抽象线程和主内存之间的关系之外，其还规定了从Java代码到CPU可执行命令的这个转换过程要遵守哪些和并发相关的原则和规范。
- 主内存：所有线程创建的实例对象都存放在主内存中，不管是实例对象的成员变量还是方法中的局部变量
- 本地内存：每个线程都有一个私有的本地内存来保存共享变量的副本。每个线程都有自己的本地内存，无法访问其他线程的本地内存。


## 25、happen-before原则：
- 为了对编译器和处理器的约束尽可能少，只要不改变程序执行结果，编译器和处理起怎么进行重新排序优化都行。
- 对于改变程序执行结果的重排序，JMM要求编译器和处理器都禁止这种重排序。
- happen-before八大原则：
    - 1、程序次序规则：在一个线程内，按照控制流程，书写在前面的操作先行发生在发生在后面的操作。
    - 2、管制锁定规则：一个unlock操作先行发生于后面的锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。
    - 3、volatile 变量规则：对于一个volatile修饰的变量的写操作优先于发生于后面对这个变量的读操作。
    - 4、线程启动规则：Thread对象的start方法发生于此线程的每个动作之前。
    - 5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测。
    - 6、线程中断规则：对线程的interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。通过interrupted()方法检测是否有中断发生。
    - 7、对象终结规则：一个对象的初始化完成先行于他的finalize()方法。
    - 8、传递性：如果A先行发生于B，B先行发生于C，那么就可以得到A先行发生于C的结论。
-  as-if-serial：不管怎么重新排序，单线程环境下的执行结果不能改变。


## 26、并发编程的三个特性：
- 原子性
- 可见性
- 有序性

## 27、常见的IO模型
- 1. BIO 同步阻塞 ：同步阻塞模型中，应用程序发起read调用后，会一直阻塞，直到内核数据拷贝到用户空间。
- 2. NIO none-blocking IO /NEW-IO？？非阻塞同步？？（可以看作是IO多路复用模型）：NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO
    - NIO采用通道和缓冲去对文件进行操作，以及用socketChannel和ServerSocketChannel进行网络传输。
    - 传统的IO采用阻塞式模型，对于每个连接，都需要创建一个独立的线程来处理读写操。当一个线程等待IO操作时，无法执行其他任务。会导致大量的线程创建和销毁，以及上下文切换，降低了系统性能。NIO使用IO多路复用模型，允许线程在等待IO时执行其他任务。这种模式通过选择器（Selector）来监控多个通道（Channel）上的I/O事件，实现了更高的性能和可伸缩性。
- 3. AIO(NIO2) 异步非阻塞的IO。异步IO是基于事件和回调机制实现的，也就是应用操作之后不会直接返回，不会阻塞那里，当后台处理完成之后，操作系统会通知相应的线程进行后续的操作。
- 4. IO和NIO的区别：
    - 可以简单认为IO是面向流的，NIO是面向块的。（缓冲区）处理
    - 面向流的I/O系统一次一个字节的处理数据
    - 面向块的I/O系统以块的形式处理数据。

## 28、IO
- IO即Input/Output，输入和输出。数据输入到计算机内存的过程即输入，计算机内存输出到外部存储（比如数据库、文件、远程主机）的过程即输出。
- IO流在Java中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。
- Java的IO是从四类基础类中派生出来的：
    - InputStream/Reader：所有的输入流的基类，前者是字节字节流，后者是字符输入流。
    - OutputStream/Writer：所有的输出流的基类，前者是字节流，后者是字符流。
- 缓冲流：
    - 字节缓冲流：IO操作是很消耗内存的，缓冲流将数据加载到缓冲去，一次性读取/写入多个字节，从而避免频繁的IO操作，从而提高流的传输效率。字节缓冲流通过装饰器模式增加（InputStream/OutPutStream）子类对象的功能。
    - 字符缓冲流：类似于字节缓冲流，内部都维护一个字节数组作为缓冲。字符缓冲流主要用来操作字符。

## 29、JavaIO的设计模式
1. 装饰器模式
- 装饰器模式：可以在改变原有对象的基础上，增强器功能。
- 对于字节流来说，FilterInputStream 和FilterOutputStream是装饰器模式的核心，分别用于增加InputStream和OutputStream子类对象的功能。
2. 适配器模式
    - 适配器模式：主要用于互补兼容的接口的协调工作。
    - 适配者：适配者模式中被适配的对象称之为适配者，作用于适配者之间的被称为适配器。
    - 适配器：适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。
3. 工厂模式：NIO中。
4. 观察者模式：NIO中的文件监听属于观察者模式。

## 29、类加载过程
- 加载：
  - 1、通过全类名获取定义此类的二进制字节流。
    - 2、将字节流所代表的静态储存结构转换为方法区的运行时数据结构。
    - 3、在内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。
- 验证：
  - 1、文件格式验证（Class文件格式检查）
    - 2、元数据验证（字节码语义检查）
    - 3、字节码验证（程序语义检查）
    - 4、符号引用验证 （类的正确性检查）
- 准备： 准备阶段是正式为类变量分配内存并设置初始值的阶段。	这些内存都在方法区中分配。
    - 1. 这些类变量只包括类的静态成员变量，而不包括实例变量。
    - 2. 字符串变量在1.7之后被移动放在堆中。
    - 3. 这里的初始值通常情况下指的是数据类型的零值。
- 解析：解析接待是程序将常量池内的符号引用替换为直接引用的过程。解析动作主要针对 类或、接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符等7种符号引用。
- 初始化：是执行类初始化方法的<clinit> ()方法的过程，是类加载的最后一步。这一步JVM才真正开始执行类中定义的Java程序代码。

##30、类卸载：即Class对象被GC
- 三个必要条件:
    - 该类的所有对象是实例被回收。
    - 该类没有在其他地方被引用。
    - 该类的类加载器被GC。

##31、Java堆空间和内存回收原则
1. 堆空间的基本结构
- 新生代
- 老年代
- 永久带(Java1.8之后用元空间取代)

2. 内存分配和回收原则
    - 对象首先在Eden区分配
    - 大对象直接进入老年代（需要大量连续内存空间的对象，例如：字符串、数组等）
    - 长期存活的对象进入老年带

3. 死亡对象的判断
    - 引用计数法：给对象添加一个引用计数器
      - 每当有一个地方引用对象，计数器就加1.
        - 当引用失效，计数器就减少1
        - 任何时候计数器为0的对象就是不可能再被使用的。
        - 这个方法实现简单，效率高，但是目前虚拟机中没有选择这个算法管理内存，因为它很难解决对象之间循环引用的问题。
    - 可达性分析算法：这个算法的基本思路就是通过一系列称为“GC Roots”的对象作为起点，从这些起点开始向下搜索，节点所走过的路径被称为引用链，当一个对象到GC-Roots没有任何引用链的话，则证明此对象是不可用的，需要被回收
4. 垃圾收集算法：
    - 标记-清除算法：标记清除算法，分为标记和清除两个阶段，首先标记可达对象，然后清除
        - 问题：1、效率：标记和清除效率都不高 2、空间问题：会产生很多不连续的空间
    - 复制算法：可以将内存分为大小相同的两块，每次使用其中的一块，当这一块使用完成之后，就将存活的对象复制到另一块去，然后把使用的空间一次清理。
    - 标记-整理算法：
    - 分代收集算法


# 二、MySQL数据库知识

## 1、 MVCC
1. MVCC是什么：多版本并发控制
2. MVCC如何实现的：依赖于隐藏字段、Read View、undo log（事务回滚日志）。
    1. 隐藏字段：
        1. DB_TRX_ID:表示最后一次更新或插入该行的事务.
        2. DB_ROLL_PTR:回滚指针。指向该行undo log
        3. DB_ROW_ID：如果没有设置主键切没有位移非控索引是。用该ID生成聚组索引。
    2. ReadView
        1.  m_low_limit_id: 目前出现的最大的事务ID+1。大于等于这个ID的数据版本均不可见。
        2.  m_up_id:活跃事务列表中最小的事务ID。小于等于这个事务ID的数据版本均可见
        3.  m_ids：创建事务时其他未提交的活跃事务ID列表。
        4.  m_create_trx_id:创建该Read View的事务ID。
    3. undo-log
        1. 两个作用：
            1. 当事务回滚时将叔恢复到修改前的样子。
            2. 另一个作用是MVCC，当读取事务时，若该记录被其他事务占用或者当前版本对该事务不可见，则可以通过undo-log读取之前的版本数据。以此实现非锁定读。

## 2、数据库三范式
- 第一范式：属性不可分割。
- 第二范式： 非主属性都依赖于主属性。
- 第三范式： 属性之间的传递依赖关系。

## 3、事务的隔离级别 ##
1. 脏读：读取了其他事务未提交的数据
2. 不可重复读： 读取了其他事务修改完的数据。
3. 幻读：事务执行过程中。其他事务插入或者删除了数据
4. 事务的隔离级别
    1. 读未提交
    2. 读已提交
    3. 可重读
    4. 线性化
5. 事务的ACID原则：
    1. 原子性：事务是最小的执行单位，不允许分割
    2. 一致性：事务执行前后，数据保持一致性
    3. 隔离性：事务之间不会相互影响
    4. 持久性：事务提交会，对数据的修改是永久的。redo-log.

## 4、MySQL数据库的基础架构
- 连接器：身份认证和权限相关（登入数据库的时候）
- 查询缓存：执行SQL语句之前会先查询缓存（MySQL 8.0 版本被移除，不实用）
- 分析器：分析SQL语句，检查SQL语句语法是否正确
- 优化器：按照MySQL认为最优的方案去优化语句
- 执行器：执行语句，然后存储引擎返回数据
- 存储引擎：主要负责数据存储和读取，采用的是插件式结构

## 5、什么是关系型数据库？
- 建立在关系模型基础上的数据库，关系模型表明了数据库中所存储的数据之间的关系。

## 6、什么是SQL语句？
- 结构化查询语句，专门用于和关系型数据库打交道。

## 7、MySQL的查询缓存？
- 开启缓存查询后在同样查询条件以及数据的基础上，会直接在缓存中返回结果。这里的查询条件包括查询本身、查询的数据库、客户端的协议版本号等一些可能影响结果的信息。
- 缓存不命中的情况：
    - 任何两个查询在任何字符上的不同都会导致缓存不命中。
    - 查询中包含自定义函数、存储函数、用户变量、临时表、MySQL中的系统表。其查询结果都不会被缓存。
    - 缓存建立以后，MySQL会跟踪涉及到的每张表，如果这些表的数据发生变换。那么这张表相关的所有缓存都会失效。

## 8、什么是事务？
- 事务就是逻辑上的一组动作，要么都执行成功，要么都不执行。

## 9、并发事务带来哪些问题？
- 脏读
- 丢失修改
- 不可重复度
- 幻读

## 10、并发事务控制的方式哪些？
- 锁：锁控制方式下会通过锁来显示控制资源而不是通过调度手段，MySQL中主要通过读写锁来实现并发控制。
  - 共享锁：又称读锁，事务在读物数据的时候获取读锁，允许多个事务同时获取
    - 排他锁：又称写锁，事务在修改记录时获取排他锁，不允许多个事务之间获取排他锁。如果一个记录已经被加了排他锁，那么事务不能再对这条记录加任何类型的锁。
- MVCC多版本并发控制：即对一份数据会存储多个版本。通过事务的可见性来保证事务能看到自己改看的版本，

## 11、InnoDB 有哪几类行锁？
- 记录锁（Record Lock）：属于当个行记录上的锁
- 间隙锁（Gap Lock）：锁定一个范围，不包括记录本身
- 临建锁（Next-Key Lock）： 锁定一个范围，包含记录本身，主要问题是解决幻读。

## 12、共享锁和排他锁？
- 共享锁（S锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
- 排他锁（X锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。

## 13、意向锁？
- 意向锁：如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。
    - 意向共享锁：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
    - 意向排他锁：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。

## 14、当前读和快照读有什么区别？
- 快照读（一致性非锁定读）就是单纯的select语句。
- 快照即记录的历史版本。
- 快照读的情况下，如果读取的记录正在执行update/Delete操作，读取操作不会因此去等待记录上X锁释放，而是回去读取行的一个快照。
- 只有事务隔离级别在RC、RR情况下，Innodb才会使用一致性非锁定读
    - 在RC级别下，对于快照读，一致性非锁定读写总是读取被锁定行的最新一份快照数据
    - RR级别下，对于快照读，一致性非锁定度总是读物事务开始时的最新一份快照数据

## 16、什么是索引？
- 索引是一种用于快速查询和检索的特殊的数据结构，其本质可以看成是一种排序好的数据结构。

## 17、索引的优缺点：
- 优点：
  - 使用索引可以大大减少查询时间。
    - 使用唯一索引可以确保数据的唯一性。
- 缺点：
    - 索引需要占用磁盘空间
    - 新建索引需要时间
    - 增删改查操作都需要维护索引

## 18、索引底层数据结构
- Hash
- 二叉查找叔
- AVL树
- 红黑树
- B树和B+树
    - B树也成 B-树，全称为多路平衡查找树，B+树是B树的一种变体。
    - B树和B+树有什么异同？
        - B树的所有节点既存放Key，也存放数据，而B+树只有叶子节点存放key和data，其他内节点只存Key、
        - B树的叶子节点都是独立的，B+树的叶子节点有一条引用链条执行他相邻的叶子节点。
        - B树的检索过程相当于范围内的每个节点的关键字做二分查找，可能还没到到叶子节点就已经结束了，而B+树就很稳定，任何查找都是从根节点到叶子节点的过程。
        - B树在范围查询是，首先需要找打需要查询的下限，然后对B树进行中序遍历，直到直到上限。而B+树的范围查询，只要对链表遍历即可。

## 19、索引的分类
- 按照数据结构分类
- hash
- B+树
- 按照底层存储方式
- 聚簇索引：索引结构和数据存放在一起的。
    - 优点： 查询速度快 ；对排序和查找范围优化
    - 缺点：依赖于有序的数据 ；更新代价大。
- 非聚簇索引：索引结构和数据不存放在一起的。二级索引就是非聚簇索引。
    - 优点：更新代价小
    - 缺点：依赖于有序的数据；可能会二次查询
- 按照应用角度划分
- 主键索引
- 唯一索引
- 普通索引
- 覆盖索引
- 联合索引
- 全文索引

## 20、联合索引
- 使用表中多个字段创建索引

## 21、最左前缀匹配原则
- 最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 >、<）才会停止匹配。对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

## 22、索引下推？
- 索引下推（Index Condition Pushdown） 是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。

##23、MySQL的日志？
- redo log（重做日志），是InnoDB独有的，他让MySQL有了崩溃恢复能力。
- bin log ：物理日志，记录内容是“在某个数据页上做了什么修改”，记录内容是语句的原始逻辑。
  - 用于数据备份、主备、主主、主从离不来bin log
- undo log
    - 我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚，在 MySQL 中，恢复机制是通过 回滚日志（undo log） 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 回滚日志 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。
    - 另外，MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改# 总结

## 24、redo-log 两阶段提交
- 原理很简单：将redo log拆分成了两个步骤 prepare 和 commit

## 25、MVCC+Next-key-Lock 防止换读。
- 执行普通select，此时会议MVCC快照读的方式读取数据。
- 执行当前读：在当前读下，读取的都是当前最新的数据，如果其他事务有插入新的记录，并且刚好在当前事务的查询范围内，就会产生幻读。InnoDB使用Next-Key Lock来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读

## 26、InnoDB为什么使用B+树索引？
- 哈希索引虽然能提供O（1）复杂度查询，但对范围查询和排序却无法很好的支持，最终会导致全表扫描。
- B 树能够在非叶子节点存储数据，但会导致在查询连续数据可能带来更多的随机 IO。
- 而 B+ 树的所有叶节点可以通过指针来相互连接，减少顺序遍历带来的随机 IO。

## 27、 drop、delete、truncate。？
- delete：DELETE 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。
- TRUNCATE TABLE：则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。
- drop语句将表所占用的空间全释放掉。
- 在速度上，一般来说，drop> truncate > delete。
- 如果想删除部分数据用 delete，注意带上 where 子句，回滚段要足够大；
- 如果想删除表，当然用 drop； 如果想保留表而将所有数据删除，如果和事务无关，用 truncate 即可；

# 三、Redis 数据库知识
## 4、Redis ##
### 4.1Redis的数据类型
1. String k/v
2. List
3. Set
4. ZSet
5. Hash

### 4.2  Redis的3种常用的读写策略。
- 1、Cache Aside Pattern 旁路缓存模式
    - 读：
        - 1、从cache种读取数据，如果缓存种有数据的直接返回。
        - 2、cache中读取不到的话，就从db中获取数据返回
        - 3、再把数据放到cache中.
    - 写：
        - 1、先更新DB
        - 2、然后直接删除cache。
    - 旁路缓存模式缺陷：
        - 1. 首次请求的数据在cache中不存在，
        - 2. 写操作比较频繁的话，会导致缓存中的数据频繁被删除，会影响缓存命中率。
    - 解决办法：
        - 数据库强一致性场景：更新db的时候同样更新cache，不过我们需要加一个锁/分布式锁来抱保证更新cache的时候不存在线程安全问题。
        - 可以短暂的允许数据库和缓存不一致的场景：更新DB的时候同时更新cache，但是给换粗加一个比较短的过期时间。

- 2、 Read/Write Through Pattern（读写穿透）
    - 读:
        - 1、从cache中读取数据，如果缓存中存在数据的话直接返回数据
        - 2、如果cache中没有数据的话，先db加载，写入到cache中后返回响应。
    - 写
        - 1、先查cache，cache中不存在，直接更新db。
        - 2、cache中存在，则先更新cache，然后cache服务自己更新DB（同步更新cache和db）。
    - 读写穿透的缺陷：

- 3、Write Behind Pattern（异步缓存写入
    - 这种方式和读写穿透的方式很相似。 两者都是有cache服务来负责cache和db读写。但是两者又有很大的不同，读写穿透是同步更细cache和db，而Write Behind则是只是更新缓，不直接更新DB，而是改为异步批量的方式更新DB

### 4.3 如何保证Redis和数据库的一致性。
1. 更新缓存数据的4种方案。
    - 先更新缓存，再更新数据库
    - 先更数据库，再更新缓存
    - 先淘汰数据，再更新数据库
    - 先更新数据库，再淘汰数据

2. 更新、淘汰数据优缺点。
    - 淘汰数据
        - 优点：操作方式简单。
        - 缺点：淘汰数据后，下一次无法在缓存中查询到，会有一次cache-miss。
    - 更新数据
        - 优点：缓存命中率高，不会造成cache-miss。
        - 缺点：1、 更新cache消耗更大。 2、并发更新到处数据不一致问题。

3. 保持数据一致性的策略。
    1. 延时双删：(1)写请求 (2)删除缓存 (3)更新数据库 (4)休眠一会，再次删除缓存。
    2. 删除缓存重试机制：
        - 写请求更新数据库
        - 缓存因为某些原因删除失败
        - 把删除的Key放入消息队列。
        - 要删除的key拉出来。
        - 重试删除操作。
    3. 读取数据库的binlog日志来异步淘汰缓存。

4. 保证本地缓存和分布式缓存的一致性。
    1. 可以使用Redis本身的Pub/Sub机制，分布式集群的所有节点都订阅删除本地缓存频道。删除Redis的节点，同时发布删除本地缓存消。
    2. 引入专业的消息队列，保证消息的可靠性，但是增加了系统的复杂性。
    3. 设置适当的过期时间兜底，本地缓存可以设置相对短一点的过期时间。

### 4.4 Redis分区方案
1. 节点取余
2. 一致性Hash分区，
3. 虚拟槽分区

### 4.5 Redis集群
1. redis集群的三种模式
    - 1. 主从模式
    1. 集群介绍
        - (1)主从模式里使用一个redis实例作为主机，其余多个实例作为备份机（slave）
        - (2)master用来支持数据的写入和读取操作，而slave节点支持读取以及master的数据同步
        - (3)在整个架构中，master和slave实例里的数据完全一致。
        2. 主从复制原理：
        - 全量同步:
            - 1、当从节点启动时，向主节点发送SYNC消息，
            - 2、主节点收到SYNC命令后，开始在后台执行保存快照的命令生成RDB文件，使用缓冲记录此后执行的所有命令。
            - 3、主节点快照完成后，将快照文件和所有缓存命令发送给集群内的从节点，并在发送期间继续记录被执行的命令。
            - 4、主节点快照发送完成后向从节点发送所缓冲区的命令。
            - 5、从节点载入快照文件后，开始接受命令请求，执行收到的主节点缓冲区的写命令。
            - 增量同步:
                - 主从复制中因为网络原因造成数据丢失的场景，当从节点再次连接主节点。如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效的避免全量复制的过高开销。
        3. 主节点故障的处理方式：
            - 主从模式中，每个客户端连接redis实例都指定了ip和端口号。如果连接的redis实例因为故障下线了，则无法通知客户端连接其他客户端，因此只能手动操作。
        4. 不支持高可用
    - 2. 哨兵模式
    1. 集群介绍：和主从模式不一样的是，哨兵模式中增加了独立进程（即哨兵）来监控集群的一举一动。客户端在连接集群时，首先连接哨兵，通过哨兵查询主节点的地址，然后再去连接主节点信息进行数据交互。如果master异常，则会进行master-slave切换，将最优的一个slave切换为主节点。同时，哨兵持续监控挂掉的节点，待其恢复后，作为新的节点假如集群中。
    2. 主节点故障处理方式/哨兵工作方式：
        - 1、每个哨兵每秒向集群中的master、slave以及其他哨兵发送一个Ping命令。
        - 2、如果某个实例距离最后一次有效回复ping命令的时间超过一定的值，则会被标记为下线。
        - 3、如果master被标记为主观下线，那么正在监视master的哨兵以每秒的频率确认其确实进入主观下线状态，且数量达到一定值时，master会被标记为下线，然后通知其他的服务器，修改配置文件，让他们切换主机。
        - 4、客户端在master节点发生故障时会向哨兵要地址，此时会获得最新的master节点地址。
        3. 扩容问题：哨兵模式的出现虽然解决了主从模式中master节点宕机不能自动切换的问题(即高可用)的问题。但是，随着业务的逐渐增长，不可避免需要对当前业务进行扩容。
        - 1、垂直扩容：通过增加master来增加容量
        - 2、水平扩容：通过增加节点来进行扩容，即在当前基础上再增加一个master节点。
            - 虽然垂直扩容方式很便捷，不需要添加多余的节点，但是机器的容量是有限的，最终还是需要通过水平扩容方式来解决。而水平扩容涉及到数据的迁移，且迁移过程中又要保证服务的可用性。因此，数据能不迁移，尽量不迁移。
            - 显然哨兵模式无法满足这种情形，因此redis-cluster应运而生。
    - 3. Redis-cluster模式
    1. 集群介绍：
        1. redis-cluster模式采用了无中心节点的方式来实现，每个主节点都会与其他节点保持连接。节点间通过gossip协议交换彼此的信息。同时每个主节点又有一个或者多个从节点。
        2. 客户端连接集群时，直接与redis集群的每个主节点连接，根据hash算法取模key存储在不同的hash槽上。
        3. 在集群中采用数据分片的方式，将redis集群分为16384个哈希槽。 这些哈希槽分别存储于三个主节点中。
            - master1负责 0-5460号哈希槽。
            - master2负责 5461-10922哈希槽。
            - master3负责 10922-16383哈希槽。
        4. 每个节点会保存一份数据分布表，节点将自己的slot信息发送到其他节点，节点间不停地传递数据分布表。
        5. 客户端连接集群时，通过集群的某个节点地址进行连接。客户端尝试向这个节点执行命令时，比如获取某个key值，如果key所在的slot刚好在该节点上，则能够直接执行成功。如果slot不在该节点，则节点返回MOVED错误，同时把该slot对应的节点告诉客户端，客户端可以去该节点执行命令。
        - 2. 主节点故障处理方式：
        1. Redis cluster中主节点故障处理方式与哨兵模式比较相像，当约定的时间内某节点无法与集群中的另一个节点顺利完成Ping消息通信时，则将该节点标记为主观下线状态，同时将这个消息向整个集群广播。如果一个节点收到某个节点失联的数量达到了集群的大多数时，那么将该节点标记为客观下线状态，并向集群广播下线节点fail消息。然后立即对该故障节点进行主从切换、等到原来的节点恢复后，会自动成为新主节点的从节点。如果主节点没有从节点，那么当他发生故障时，集群就将处于不可用状态、
        - 3. 扩容问题：
        1. 当集群中加入新节点时，会与集群中的某个节点进行握手，该节点会把集群内的其他节点信息通过gossip协议发送给新节点，新节点与这些节点完成握手后加入到集群中。 然后集群中的节点会各自取一部分哈希槽分配给新节点。当集群要删除节点时，只需要将节点中的所有哈希槽移动到其他节点，然后再移除空白的节点就可以了。




# 四、Spring框架知识
## 一、Spring的生命周期 #
1. 找到SpringBean的定义。
2. 利用Java Reflection API 创建一个bean实例
3. bean对象的属性注入
4. bean的初始化过程
    1. 查看Aware接口。BeanNameAware、BeanClassLoaderAware、BeanFactoryAware。。。起亚
    2. 查看是否有PreBeanPostProcessor
    3. 检查InitializingBean以决定屌用afterProperties方法
    4. 检查是否配置有自定以的init-method方法。
    5. BeanPostProcessor方法。
4. bean的销毁
    1. 是实现了DisableBean接口。执行destroy方法
    2. 是否配置了destroy-method属性。执行指定的方法。


## 二、SpringBean对象的三级缓存 ##
1. 一级缓存：实例对象的Map。
2. 二级缓存：实例化未初始化完成的实例对象。
3. 三级缓存：对象工厂的缓存。

## 三、SpringAOP  ##
1. 概念
    1. 目标：被通知的对象
    2. 代理：向目标对象应用通知之后创建的对象
    3. 连接点：目标对象的所属类中，所有的方法都是连接点
    4. 切入点：被切面拦截/增加的连接点
    5. 通知：增加的逻辑/代码。
    6. 切面：切入点+通知。
    7. 织入：将通知应用到目标对象，生成代理对象的过程动作。
2. 通知的类型有哪些
    1. Before 前置通知
    2. After 后置通知
    3. AfterReturning 返回通知
    4. AfterThrowing 异常通知
    5. Around 环绕通知
3. AOP如何实现
- 1、定义一个AOP类。 @Aspect
- 2、定义切入点：@PointCut
- 3、定义通知
    - @Before
    - @After：目标方法执行完毕后立即执行，无论方法是否抛出异常或者返回什么值。它通常用于释放资源、清理上下文等操作。
    - @AfterReturn：只会在方法正常返回后执行，并且可以访问方法的返回值。如果方法抛出异常，它不会被执行。
    - @AfterThrowing
    - @Around

4. 全局异常捕获
- @ControllerAdvice + @ExceptionHandler。 可以自定义异常类。也可以使用Exception.class。

5. 多个切面的顺序如何控制。
- @Order注解直接定义切面顺序
- 实现Ordered接口，重写getOrder方法

## 五、SpringIOC和AOP概念 ##
1. IOC：控制反转。
    1. 控制反转就是把对象的创建和管理bean的过程转移给了第三方。而这个第三方就是SpringIocContainer
        2. 容器负责创建、配置和管理Bean。他就控制着bean的生命，控制着bean的依赖注入。
    2. 只需要配置对象信息即可。 @Auto  @Resource @Repository  @Bean @Service @Controller
2. AOP：面向切面的编程思想，将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑使可以专心于核心业务，从而提高开发效率。大大减少了重复代码。
- 通过代理实现
    - 1、通过JDK动态代理实现：InvocationHandler个Proxy类
    - 2、通过CGlib动态代理：MethodInterceptor 和 Enhancer。


## 六、SpringMVC ##
1. 什么是SpringMVC
    1. 什么是MVC Model View Controller 模型-视图-控制器。是一种将业务逻辑处理、数据和显示分离的方法。
        - Model是用来处理应用数据逻辑的部分。通常模型对象负责在数据库中读取数据。
        - View（视图）：是应用程序中处理数据显示的部分。通常视图是一句模型数据创建的。
        - Controller ：处理用户交互的部。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据
    2. SpringMVC：就是在Spring Container Core和AOP 等技术的基础上，遵循MVC规范推出的Web框架。目的是简化Web开发。

1. 核心组件：DispatcherServlet 、HandMapping、HandlerAdapter、ModelAndView
2. 请求的流程
    1. 浏览器发送请求。DispatchServlet接受到请求。
    2. DispatchServlet->HandlerMapping .HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器、多个HandlerInterceptor拦截器。
    3. DispatchServlet-> HandlerAdapter 会把处理器包装成适配器。从而支持多种类型的处理器，即适配器设计模式的应用。
    4. HandlerAdapter->处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处 理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；
    5. ModelAndView的逻辑视图名 -> ViewResolver, ViewResolver将把逻辑视图名解析为具体的View。
    6. View -> 渲染， View根据传来的Model模型数据进行渲染，
    7. 返回控制权限给DispatchServlet。由DispatchServlet返回响应给用户。


## 七、Spring事务管理 ##
1. **Spring事务有哪几种传播行为(7种。)**
    1. TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务则加入该事务，如果没有事务则创建。
    2. TransactionDefinition.PROPAGATION_ REQUIRES_NEW：创建一个新的事务。如果当前存在事务，则把当前事务挂起。
    3. TransactionDefinition.PROPAGATION_NESTED：创建一个新的事物。如果当前存在事务，则嵌套到当前事务来运行。（父子任务回滚）
    4. TransactionDefinition.PROPAGATION_MANDATORY：如果当前有事务的，则加入打当前事务，如果没有的，则抛出异常。

    5. TransactionDefinition.PROPAGATION_SUPPORTS：如果当前有事务的，则加入该事务，如果没有的则非事务方式运行。
    6. TransactionDefinition.PROPAGATION_ NOT_SUPPORTED：非事务方式运行。当前存在事务的就挂起。
    7. TransactionDefinition.PROPAGATION_NEVER：非事务方式运行。如果当前存在事务的，则抛出异常。

2. 事务隔离级别
    1.  Default:使用数据库默认的隔离级别
    2.  读未提交
    3.  读已提交
    4.  可重复度
    5.  线性化

## 八、 Spring中的事件驱动（观察者模式）是什么？？ #
1. 首先理解观察者模式是什么：当某个事件发生时，其会被广播出去，监听该事件的listener就会被触发并执行相应的动作。
    1. 观察者模式：是一种对象行为模式。表示一种对象和另一种对象之间具有依赖关系，当一个对象发生改变时，依赖这个对象的所有对象也会做出反应。
    2. Spring的事件驱动是观察者模式的经典应用。
    3. Spring事件驱动的三种角色：
        1. 事件角色：ApplicationEvent充当事件角色，继承可JDK中的EventObject并实现了Serializable接口。
            1. Spring默认存在以下事件，都是ApplicationEvent的实现（继承自ApplicationEvent类）
                1. ContextStartedEvent:ApplicationContext启动后触发的事件
                2. ContextStoppedEvent：ApplicationContest停止后触发的事件
                3. ContentRefreshedEvent：ApplicationContext初始化或者刷新完后触发的事件
                4. ContentClosedEvent：ApplicationContext关闭后触发的事件。
        2. 事件监听者角色：ApplicationListener充当了事件监听者角色。定义了一个onApplicationEvent()方法了处理ApplicationEvent。
            - @EventListener + @Component\@Service  或者实现ApplicationListener方法。
            - @TransactionalEventListener 注解。：是对@EventListener的一个扩展，允许将事件的监听器绑定到事务的某个阶段。可以绑定一下事务阶段：
                - AFTER_COMMIT：事务提交之后
                - AFTER_ROLLBACK：事务回滚后
                - AFTER_COMPLETION：事务完成，包括提交和回滚后
                - BEFORE_COMMIT：事务提交前
            - @TransactionalEventListener注解指不和发布事件的方法在同一个事务内，发布事件的方法在事务结束后才会执行本监听方法。监听器内部发生异常不会回滚发布事件方法的事务。
        3. 事件监发布者角色：ApplicationEventPublisher充当了事件发布者，他也是一个接口。定义了publishEvent方法。
            - ApplicationContext实现了 ApplicationEventPublish接口

    4. 事件驱动的好处
        1. 没有耦合的关联。事件发布者不需要预先知道订阅者的存在。
        2. 异步消息传递，业务逻辑可以同时发生。
        3. 多对多的交互，发布订阅模式。


## 九、Spring中拦截器、过滤器、监听器的区别 ##
1. 拦截器Interceptor：拦截器是依赖于IOC容器的，在实现上面基于Java动态代理实现。是AOP的一种表现。
    1. 实现HandlerInterceptor接口
    2. 通过WebMvcConfig配置，注册过滤器。
2. 过滤器：过滤器是Servlet容器层面的，在实现上基于函数回调，可以对几乎所有的请求进行过滤。过滤器是对数据进行过滤，预处理的过程。
    1. Spring实现过滤器的方式
        1. 无路径、无顺序@Component。直接实现Filter接口。并使用@Component注解。
        2. 有路径无顺序 @WebFilter+@ServletComponentScan:通过实现Filter接口，并增加@WebFilter注解。需要在启动类中家@ServletComponentScan注解（扫描@WebFilter,@WebServlet，@WebListener并注入bean）。
        3. 有顺序有路径
            1. @Configuration+@Bean+ FilterRegistrationBean实现。
3. 监听器：监听器也是Servlet层面的，可以用于监听Web应用中的某些对象，信息的创建、销毁和修改等动作发生，然后做出相应的响应处理。
   #### 1. 监听器分为三类 #
    1.  ServletContext，实现接口ServletContextListener。
    2.  HttpSession，实现接口HttpSessionListener。
    3.  ServletRequest，实现接口ServletRequestListener。
   ####  2. 实现方式和Filter一样。
    - 一种是只加@Compoonent并实现接口 。
    - 另一种是@WebListener和@ServletComponentScan一起使用。

### 拦截器、监听器、过滤器的不同点 ###
1. 实现方式不同。
    1. 拦截器：代理模式。
    2. 过滤器：回调函数。
    3. 监听器：事件。
2. 依赖不同：过滤器和监听器都是在WebServlet容器中。 过滤器是在SpringIOC容器中。
3. 使用场景不同<br/>
   （1）过滤器：设置字符编码、URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等、身份验证、资源过滤<br/>
   （2）拦截器：拦截未登入、审计日志等<br/>
   （3）监听器：统计在线人数、清除过期Session<br/>
4. 触发的时机不一样：过滤器实在请求进入容器之后，但是在servlet之前进行预处理的，请求结束返回也是，实在servlet处理完后，返回给前端之前。 而拦截器实在

# 五、SpringBoot框架知识
## 一、SpringBoot知识 ##
## 1. SpringBoot的启动流程 ## 
[https://blog.csdn.net/BASK2311/article/details/129703129#:~:text=SpringBoot%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%201%201.%20%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E5%90%AF%E5%8A%A8%E7%B1%BB%202%202.%20%E5%88%9D%E5%A7%8B%E5%8C%96Spring%E5%AE%B9%E5%99%A8%203,3.%20%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8A%9F%E8%83%BD%204%204.%20%E5%90%AF%E5%8A%A8%E5%86%85%E5%B5%8C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%205%205.%20%E5%90%AF%E5%8A%A8SpringBoot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F](https://blog.csdn.net/BASK2311/article/details/129703129#:~:text=SpringBoot%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%201%201.%20%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8E%E5%90%AF%E5%8A%A8%E7%B1%BB%202%202.%20%E5%88%9D%E5%A7%8B%E5%8C%96Spring%E5%AE%B9%E5%99%A8%203,3.%20%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8A%9F%E8%83%BD%204%204.%20%E5%90%AF%E5%8A%A8%E5%86%85%E5%B5%8C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%205%205.%20%E5%90%AF%E5%8A%A8SpringBoot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F "参考地址")
1. 执行构造函数。
2. 加载配置文件与启动类：当Springboot项目启动时，会首先读取项目中的配置文件，主要是application.yaml和application.properties文件。这些文件会指定启动端口号、数据库连接等一系列配置信息。同时，SpringBoot也会加载启动类，这个类中有@SpringBootApplication注解。
2. 初始化Spring容器：包括初始化bean实例，依赖注入等
3. 开启自动配置功能：扫描项目中的类，自动注册bean。
4. 启动内嵌的Web服务器，启动内嵌的Web服务器，比如Tomcat或者Jetty，在Web服务器上部署应用
5. 启动Springboot应用程序

1. 执行构造函数 SpringBootApplication
    1. 构造函数完成的四件事情
        1. 推断当前项目是否是web项目
        2. 加载所有的初始化器
        3. 加载所有的监视器
        4. 设置程序运行的主类
2. 运行Run方法
    1. 计时器实例并启动
    2. 初始化监听器
    3. 启动监听器
    4. 装配环境参数
        - 根据前面的webApplication值创建运行环境
        - 加载属性资源
        - 加载预监听器集合
    5. 打印banner图案
    6. 上下文区域：根据webApplicationType类型创建web/standard上下文，即创建servlet/reactive的上下文。
    7. 准备上下文异常报告
    8. 上下文前置处理器
        1. 该方法做了三件之。environment环境设置、initialize初始化设置、资源获取并加载以及配置监听
    9. 上下文刷新
        - 这里就是著名的方法。设置bean工厂、生产bean、注册后置处理器、初始化国际化资源、注册监听器。这里要注意的是onRefresh()方法。在这个方法里，最终创建了内置的Tomcat容器。
    10. 上下文后置处理器
        - 这里会把计时器结束。
    11. 发布应用上下文启动
    12. 执行Runner执行器
    13. 发布应用上下文就绪并返回
    3.

## 2. SpringBoot集成mybatis和数据库的流程 ##
1. 首先引入依赖jar包。
2. 配置数据库连接信息
3. 新建Dao类
4. 新建Mapper接口
5. 新建Mapper.xml文件
6. 新建Service接口和实现类
7. 新建Controller类。测试数据

## 3. SpringBoot的自动装配原理 ##
1. @SpringBootApplication注解可以看作是三个注解的集合
    1. @EnableAutoConfiguration：启用SpringBoot的自动配置机制 @Import ( AutoConfigurationImportSelector.class)
    2. @SpringBootConfiguration：根据Javadoc可知，该注解作用就是将当前的类作为一个JavaConfig，然后触发注解@EnableAutoConfiguration和@ComponentScan的处理，本质上与@Configuration注解没有区别
    3. @ComponentScan：扫描被@Component（@Service ,@Controller）注解的bean，注解默认会扫描启动类所在的包下所有类，可以自定义不扫描某些bean
    4. AutoConfigurationImportSelector加载自动装配类，实现了ImportSelector类，完成了以下工作
        1.  判断自动装配器开关是否打开。
        2.  获取EnableAutoConfiguration注解中的exclude和excludeName。
        3.  获取需要自动配置的所有配置类，读取 META-INFO/spring.factories，读取对应的EnableAutoConfiguration.class类名对应的值
        4.  根据类上的注解判断，若条件满足，则该配置类生效。
            - eg
            - @ConditionOnBean
            - @ConditionOnMissingBean
            - @ConditionOnSingleCandidate
            - @ConditionOnProperty
            - ...
## 4.介绍一下SpringBoot，有哪些优点？
- SpringBoot基于Spring框架开发，用于快速、敏捷的开发新一代Spring应用程序的框架。不是用于替代Spring框架，而是用于提升Spring开发者体验的框架。
- SpringBoot以"约定大于配置"核心思想展开工作，相比Spring有以下优势。
    - 1、SpringBoot可以快速的创建Spring应用程序
    - 2、SpringBoot内嵌Tomcat、Jetty、Undertow这样的容器。
    - 3、无需再像Spring一样配置大量的xml文件
    - 4、SpringBoot可以自动配置。将原有的XML配置修改为Java配置，将bean注入改为使用@Autowire
    - 5、提供现有的功能
    - 6、快速整合常用依赖。spring-webmvc。提供的POM可以简化maven配置。当我们引入核心依赖时，SpringBoot会自动引入其他依赖。

# 六、MyBatis框架知识
## 1、什么是Mybatis ##
### 优点 ###
1.	mybatis是一个半ORM（对象关系映射）框架，底层封装了JDBC，开发时只需要关心SQL本身，而不需要进行驱动加载、数据库连接、创建statement等操作。
2.	可以通过XML文件配置或者注解方式配置映射原生关系，可以将POJO配置成数据库中的记录，避免了JDBC代码，手动配置参数，获取结果集等。

### 缺点 ###
1. SQL语句的编写量大
2. SQL以来于数据库。导致代码移植性差。不能随意切换数据库。


## 2、ORM是什么 ##
1. ORM（Object Relation Mapping）:对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单来说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。


## 3、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？ ##

- Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
- 而Mybatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，被称之为半自动ORM映射工具。

## 4、Hibernate和Mybatis有什么区别 ##
### 相同点 ###
- 都是对JDBC的封装，都是持久层的框架

### 不同点
1. 映射关系不同
2. SQL优化和移植性
    1. Hibernate。对SQL语句进行了封装，还提供了日志、缓存、关联等功能。提供了HQL语句操作数据库。数据库无关性好，但是会消耗性能。 SQL语句优化较难
    2. MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。
3. 使用场景不同
    1.	Hibernate 是标准的ORM框架，SQL编写量较少，但不够灵活，适合于需求相对稳定，中小型的软件项目，比如：办公自动化系统
    2.	MyBatis 是半ORM框架，需要编写较多SQL，但是比较灵活，适合于需求变化频繁，快速迭代的项目，比如：电商网站


## 5.Mybatis的使用过程、生命周期 ##
1. 创建SQLSessionFactory
2. 创建SQLSession
3. 查找Mapper
4. 执行SQL语句 /提交事务
5. 关闭Session

## 6、在Mapper如何传入多个参数 ##
- 顺序传参法
- @Param注解传参法
- Map传参法
- javabean传参法

## 7、实体类属性明和表字段名不一样怎么办 ##
- SQL语句定义字段的别名和实体类一致
- ResultMap来映射字段名和实体类属性名一一对应。

## 8、Mybatis是否可以映射Enum类 ##
- 可以，不但可以映射枚举类。可以映射任何对象到。通过自定义一个TypeHandler。 setParamter()方法和 getResult()方法
- TypeHandler有两个作用。一个是完成JDBCType到JavaType的转换，另外一个是JavaType到JdbcType的转换。体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。

## 9、\#{} 和${} 有什么区别##
- \#{} 是占位符，会进行预编译处理，${}是拼接符，字符串替换。没有预编译处理。
- \#{}传入参数是以字符串传入，会将 SQL中的#{}替换为？号，调用PreparedStatement的set方法来赋值。
- \#{}可以有效的防止SQL注入，提高系统安全行，${}不能防止SQL注入。
- \#{}变量替换实在DBMS中。${}变量替换实在DBMS外。

## 10、 mybatis能执行一对一和一对多的关联查询吗？ ##
- 支持。不止支持一对一、一对多的关联查询。还支持多对多、多对一的关联插叙。
- 一对一 association
- 一对多 collection

## 11、 Mybatis是否支持延迟加载？原理？ ##
- 支持。Mybatis支持association关联对象和collection关联集合对象的延迟加载。在mybatis配置中，可以配置是否延迟架子啊。lazyLoadingEnabled=true|false.
- 他的原理是，使用Cglib创建目标对象的代理对象。当调用目标方时。进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发下a.getB()是null值，那么就会单独发送事先保存号的查询关联b对象的SQL。把b查询上来。然后调用a.setB(b)，那么a的对象属性b就优质。

## 12、如何获取生成的逐渐 ##
- 新增标签中添加keyProperty="ID"即可。

## 13.Mybatis支持动态SQL吗 ##
- Mybatis有一些支持动态语言的标签。通过OGNL从SQL参数对象中计算表达式的值，根据表达式的值动态拼接SQL，以此来完成动态SQL语句的功能。
- if where foreach set
- choose(when otherwise)

## 14.Mybatis如何执行批量操作 ##
1. foreach标签。 可以在SQL语句中迭代一个集合。
- foreach标签的属性
    - item
    - index
    - open
    - close
    - separator
    - collection
- collection。该属性值是必须指定的。但是不同情况下。该属性的值是不一样的。主要有以下三种情况
    - 1、如果传入的是单个参数且参数类型是一个List的时候，collection属性值为list
    - 2、如果传入的是单个参数且参数类型是一个array数组的时候，collection的属性值为array。
    - 3、如果传入的十多个参数的时候。 我们就需要把他封装成一个map了。map的key是参数名。这个时候collection属性值就是传入的list或者array对象在自己封装的map里面的key

2. 使用ExecutorType.BATCH


## 15.说说Mybatis的以及缓存和二级缓存 ##

1. 一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为SQLSession.各个SqlSession之间的缓存相互隔离，当Session flush或close后，该SqlSession中的所有cache就将清空。mybatis默认打开一级缓存。
2. 二级缓存：二级缓存与一级缓存的机制相同。默认也是采用PerpetualCache。不同之处在于其存储的作用域为Mapper。可以在多个SQLSession之间共享。并且可以自定义存储源。默认不开启二级缓存。使用二级缓存属性需要实现Serializable序列化接口，可以在映射文件中配置。

## 16、Mybatis工作原理  ##
- 构建会话工厂
1. 读取Mybatis配置文件 --- mybatis-config.xml文件、加载映射问价按---映射文件机SQL映射文件。文件配置了操作数据库的SQL语句。最后生成一个配置对象。
2. 构造会话工厂：通过Mybatis的环境变量等配置信息构建会话工厂SqlSessionFactory。

3. 创建会话对象：有会话工程创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。
- 会话运行
4. Executor执行器：Mybatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态生成需要执行的SQL语句。同时负责查询缓存的维护。
5. StatementHandler：数据库会话器，串联起参数映射的处理和运行结果映射的处理
6. 参数处理：对输入参数的类型进行处理，并预编译
7. 结果处理：对返回结果类型进行处理。根据对象映射规则。返回相应的对象。

## 17、Mybatis的功能架构是怎么样的？
- 我们一般把mybatis的功能架构分为三层：API接口层、数据处理层、基础支撑层
    - API接口层：提供给外部使用的API接口，开发人员通过这些本地API来操作数据库
    - 数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。
    - 基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理。

## 18、为什么Mybatis的接口不需要实现？
- Mybatis通过动态代理的方式生成具体的代理类。因此开发者本身不需要实现接口。
    - 获取Mapper的过程
        - Mapper =》MapperProxyFactory=》MapperProxy=》MapperMethod=》execute
        - 获取Mapper，首选需要获取MapperProxyFactory对象，通过该对象创建MapperProxy对象。通过执行MapperMethod执行SQL语句。

## 18、Mybatis都有哪些执行器？
- 有三种基本执行器SimpleExecutor、ReuseExecutor、BatchExecutor
    - SimpleExecutor:每执行一次update或者select，就开启一个是Statement对象，用完立刻关闭
    - ReuseExecutor:执行Select或select，以SQL为key创建Statement对象，存在则使用，不存在则创建。用完后，不关闭Statement对象，而是放在Map<String,Statement>中，供下一次使用。
    - BatchExecutor:执行Update(没有Select)，将所有sql都添加到批处理中（addBatch），等待统一执行（executeBatch()），它缓存了多个statement对象，每个对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。
- 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。
### Mybatis如何指定使用哪种Executor？
- mybatis配置文件中配置。也可以手动给DefaultSqlSessionFactory的创建SqlSession方法传递ExecutorType。

## 19. 除了常用的 select、insert、update、delete标签。还有什么标签。
- resultMap include sql if where choose set foreach collection association等。

## 20. Mybatis是如何进行分页的
(1) 使用RowBounds对象进行分页，他是针对ResultSet结果集进行的内存分页，而非物理分页。
(2) 使用物理分页的SQL语句实现物理分页功能。
(3) 使用分页插件进行分页。

## 21.Mybatis插件的原理是什么？
1. Mybatis通过 Executor【SQL执行器】、StatementHandler【Sql语法构建对象】、ParameterHandler【参数处理器】、ResultSetHandler【结果集处理器】四大扩展机制完成自定义插件实现。
- Mybatis回话的运行需要 Executor 、StatementHandler、ParameterHandler、ResultHandler四大对象配合。插件的实现原理就是在这个四大想调用的时候，插入我们自己的代码。
- Mybatis提供了Plugin类，实现了InvocationHandler接口，使用Plugin生成对象，代理对象在调用方法的时候就会进入invoke方法。在invoke方法中，如果存在签名的拦截方法，插件的intercept方法就会在这里被我们调用，然后就返回结果。如果不存在签名方法，那么将直接反射调用我们要执行的方法。
    - 所以自定义拦截器的过程
    - 1、实现Interceptor接口
    - 2、然后再给插件添加注解，确定要拦截的对象。要拦截的方法。
2. 分页插件的实现原理：
    - 根据mybatis提供的插件接口，实现自定义插件。拦截了Executor的query方法，在执行sql的时候，拦截执行的SQL，根据dialect方言，重写SQL。
        - 分页插件过程
            - 1、首先判断是否需要分页
            - 2、判断是否需要count
            - 3、判断是否需要分页查询
            - 4、

## 22、Mapper接口为什么不需要实现？
- Mapper都是通过动态代理方式生成的。不需要实现。
    - 获取Mapper的过程

    
# 七、Kafka知识
## 1、Kafka是什么 #
1. kafka是一个可扩容弄的、容错的、分布式的、基于分区的、多副本的，基于Zookeeper框架的发布-订阅消息系统，是由Scala语言开发的，他的Java版本称为Jafka。

## 2、Kafka的设计
- Kafka中的重要组件
    - 1、Producer：消息生产者
    - 2、Broker：一个Kafka节点就是一个Broker，多个Kafka可组成一个集群。
    - 3、Topic：消息主题。每条发布到Kafka集群的消息都会归集于此。
    - 4、Partition：分区Partition
    - 5、Consumer：从kafka集群中消费消息的终端或服务
    - 6、Consumer Group：每个Consumer都属于一个ConsumerGroup，每条消息都只能被ConsumerGroup中的一个Consumer消费，但可以被多个ConsumerGroup消费。
    - 7、Replica：Partition的副本，用来保障Partition的高可用性。
    - 8、Controller：Kafka集群中的其中一个服务器，用来Leader-election以及各种Failover操作。
    - 9、Zookeeper：kafka通过Zookeeper来存储集群中的meta消息。

## 3、Kafka高性能的原因：
- 利用了PageCache
    - 读数据时。不直接读取磁盘数据，而是先通过读取PageCache数据，查看是否有数据，如果有则直接返回。如果没有，则查询磁盘数据，再将数据放到PageCache中。
    - 写数据时，不直接写入磁盘，而是写入PageCache中。页缓存数据同步到磁盘文件是有操作系统来控制的。即操作系统通过一个内核后台线程，没5秒检查一次是否需要将缓存数据同步到磁盘，如果超过指定的时间，或者超过指定的大小，则将页缓存数据同步到磁盘。
- 零拷贝技术：利用了DMA技术。 减少数据拷贝   Read Buffer > WebApplicationBuffer >  Socket Buffer  ..x  Read Buffer > NICBuffer
- 磁盘顺序写:
    - 当broker接收到producer发送过来的消息是，需要根据消息的主题和分区信息，将该消息写入到该分区的当前最后segment文件中，文件的写入方式是追加写。
    - 由于是对segment文件追加写，故实现了对磁盘文件的顺序写，避免磁盘随机写时的磁盘寻道的开销，同时由于追加写，故写入的速度与磁盘文件大小无关。
- pull拉模式：Kafka消费者采用pull拉模式来消费消息。

## 4、Kafka文件搞笑存储设计原理
- 1、kafka把topic中一个Partition大文件分成多个小文件分段，就容易删除已经消费完成的文件，减少磁盘占用。
- 2、通过索引信息可以快速定位到Message和确定Response的大小
- 3、通过索引文件全部映射到memory，可以避免Segment问价的磁盘I/O操作。
- 4、通过索引文件稀疏存储，可以大幅减少索引文件元数据占用空间大小。

## 5、Kafka的优缺点
- 优点
    - 高性能、高吞吐量、低延迟
    - 高可用
    - 高并发
    - 容错性
    - 高扩扎性
- 缺点：
    - 没有完整的监控工具
    - 不支持通配符主题选择。

## 6、Kafka的应用场景
- 日志聚合
- 消息系统
- 系统解耦
- 流量削峰
- 异步处理

## 7、Kafka中分区的原则
- 指明分区的情况下，直接发送到指定分区
- 不指明分区，但指定key的情况下，根据key计算hash值。然后用分区数取余得到分区
- 不指明分区，也不指定key的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上递增），将这个数和分组总数取余得到分区值。就是常说的round-robin算法。

## 8、为什么把消息分区？
- 方便在集群中扩展
- 提高并发能力

## 9、Kafka中生产者运行流程
-  1、一条消息首先被封装成ProduceRecord对象。
-  2、对该对象进行序列化处理（可以使用默认，也可以自定义序列化）
-  3、对消息进行分区，分区时候需要获取集群的元数据，决定这个消息送到哪个主题的哪个分区
-  4、分区好的消息不会直接发送到服务端，而是放入生产者的缓存区，多条消息会被封装成一个批次（Batch）。默认一个批次的大小是16kb
-  5、Sender线程启动以后会从缓存里面获取可以发送的批次。
-  6、Sender线程把一个一个批次发送到服务端。

## 10、Kafka中的消息封装
- 在Kafka中Producer可以Batch的方式推送数据达到提高效率的作用。KafkaProducer可以将消息在内存中累积到一定数量后作为一个Batch发送请求。Batch的数量大小可以通过Producer的参数进行控制，可以从三个维度进行控制。
    - 累计消费的数量
    - 累计的时间间隔
    - 累计的数据大小
- 通过增加Batch的大小，可以减少网络请求和I/O的频次。

## 11、 Kafka的消费模式
- Kafka采用Pull拉取的模式。
- 采用Pull模式的好处是，消费者可以自主决定是否批量的从Broker拉取数。Pull有个缺点是，如果Broker没有可提供消费的消息，将导致consumer不断在循环中轮询，知道消息到达。为了避免这一点。Kafka有个参数可以让消费者阻塞直到新消息到达。

## 12、 Kafka的负载均衡
- 分区replica负载均衡：
    - 创建副本的过程：
        - 随机挑选一个startIndex
        - 从startIndex开始按照broker顺序，生成第一个副本
        - 下一轮从start-Index开始，顺序生成第二个副本。
    - 这里的随机挑选也是负载均衡的一部分。让分区尽肯能打散到各个broker

- leader均衡
    - 基于优先副本。也就是挑选AR列表中的第一个brokerId上的副本成为leader
    - 提供了分区自动平衡的功能。auto.leader.rebalance.enable.默认为true。
        - 开启之后，controller会启动一个定时任务，每隔一段时间去轮询所有的broker，计算每个broker节点的分区不平衡率。查看是否超过了设定的阈值，如果超过了自动进行分区迁移。

- consumerGroup负载均衡
    - RangeAssignor：在保证均衡的前提下，将连续的分区分配给消费者。按照topic对应的每个区段分配给Consumer实例。 造成先分配分区的Consumer实例的任务过重。
    - RoundRobinAssignor：在保证均衡的前提下，轮询分配。拿到组内所有的Consumer Topic Partition。按照顺序分发给Consumer。可能造成分区分配的倾斜。
    - StickAssignor：
        - 主要实现了两个功能：
            - 1、主题分区的分配要尽可能的均匀。
            - 2、当Rebalance发生时，尽可能保持上一次的分配方案。

## 13、 Kafka的故障转移（failover）
- 故障转移指的是，当运行中的容器突然宕机或者意外终止时，kafka能够快速地感知到，并立即启用备用控制器来代替之前失败的控制器。这个过程就是Failover，该过程是自动完成的，无需手动干预。
  -最开始时，Broker 0 是控制器。当 Broker 0 宕机后，ZooKeeper 通过 Watch 机制感知到并删除了 /controller 临时节点。 之后，所有存活的 Broker 开始竞选新的控制器身份。Broker 3 最终赢得了选举，成功地在 ZooKeeper 上重建了 /controller 节点。之后，Broker 3 会从 ZooKeeper 中读取集群元数据信息，并初始化到自己的缓存中。 至此，控制器的 Failover 完成，可以行使正常的工作职责了。

## 14、 Zookeeper在Kafka中的作用。
- Kafka 是一个使用 Zookeeper 构建的分布式系统。Kafka 的各 Broker 在启动时都要在Zookeeper上注册，由Zookeeper统一协调管理。如果任何节点失败，可通过Zookeeper从先前提交的偏移量中恢复，因为它会做周期性提交偏移量工作。同一个Topic的消息会被分成多个分区并将其分布在多个Broker上，这些分区信息及与Broker的对应关系也是Zookeeper在维护。

## 15、Kafka中消息偏移的作用。
- 生产过程中给消息提供一个顺序ID号，称之为偏移量，偏移量主要作用是惟一的区别分区中的没条消息。Kafka的存储文件都是按照offset.kafka来命名的。

## 16、Kafka中Replica、Leader、Follower的概念。
- Replica： Kafka中的Partition是有序消息日志，为了实现高可用性。需要采用备份机制。将相同的数据复制到多个Broker上，这些备份日志就是Replica，目的是为了防止数据丢失。
- Leader：副本中的领导者。负责对外提供服务。
- Follower：副本中的追随者，被动地追随leader，不能与外界进行交付。只能向leader发送消，请求leader把最新的消息发送给他。从而保持同步。

## 17、Kafka中的Geo-Replication
- Geo-Replication：异地数据同步技术
    - Kafka官方提供了MirrorMaker组件，作为跨集群的流数据同步方案。借助MirrorMaker，消息可以跨多个数据中心或云区域进行复制。您可以在主动/被动场景中将其用于备份和恢复，或者在主动/主动方案中将数据放置得更靠近用户，或支持数据本地化要求。
    - 它的实现原理比较简单，就是通过从源集群消费消息，然后将消息生产到目标集群，即普通的消息生产和消费。用户只要通过简单的Consumer配置和Producer配置，然后启动Mirror，就可以实现集群之间的准实时的数据同步.

## 22、Kafka中AR、ISR、OSR的概念
- AR：分区中所有的副本
- ISR：所有与副本保持一定程度同步的副本（包括主副本）
- OSR：与主副本滞后过多的副本组成OSR

## 23、分区中的副本什么情况下会从ISR中剔除。
- Leader会维护一个与自己基本保持同步的Replica列表，称为ISR。每个分区都有一份ISR，由Leader动态维护。所谓动态维护就是指如果一个Follower比一个Leader落后太，或者超过一定时间没有发起数据复制请求，则leader将follower从ISR中剔除。

## 24、分区中副本的Leader如果宕机但ISR为空该如何处理？
- unclean.leader.election参数
    - true：允许OSR成为leader。
    - false：一直等待旧leader恢复。

## 25、如何判断一个Broker是否有效？
- Broker必须可以维护和zookeeper的连接。zookeeper通过心跳机制检查每个节点的连接。
- 如果broker是个follower，他必须能及时同步leader的消息，延迟不能太久。

## 26、Kafka可以接收的消息最大默认是多少？如何修改
- 默认是100_0000字节。
-  Message.max.bytes。

## 27、Kafka的ACK机制？
- Kafka的ACK机制指的是 Kafka发送者发送消息给服务端的发送确认机制。
- kafka有三种ACK机制。对应的值分别是 -1、0、1
    - 0：相当于异步操作，Producer不需要Leader给予回复，发送完就认为成功。继续发送下一条。
    - 1：Kafka设置的默认值，表示Producer要Leader确认已经成功收到数据才发送下一条。
    - -1：Leader接收到消息后，还必须要求ISR列表里跟Leader保持同步的那些Follower都确认消息已同步，Producer 才发送下一条（批）Message。此机制持久性可靠性最好，但延时性最差。


## 28、Kafka的日志保留与数据清理策略
- 概念：保留期内保留所有的已经发布的消息，超过保期的数据将被按清理策略进行清理。
    - 清理策略；
        - delete：
        - 压缩：

## 29、Kafka的message是什么格式的？
- Kafka的message都由一个固定长度的header和可编程度的body组成。将Message存储在日志时采用不同于Producer发送的消息格式。每个日志文件都是一个log entries（日志项）序列：
    - 1、一个log entry包含一个四个字节整型数（Message长度：值为1+4+N）
    - 2、一个字节的magic。magic表示本次发布kafka服务程序协议版本号。
    - 3、4个字节的CRC32值，CRC32用于校验Message
    - 4、最终N个字节的消息数据。

## 30、Kafka是否支持多租户隔离？
- 多租户技术是一种软件架构技术，它是实现如何在多用户的环境下共用相同的系统或组件的程序组件，并且认可确保用户数据的隔离性。
- 解决方案：通过配置哪个主题可以生产或者消费数据来启用多租户，也有对配额的操作支持，管理员可以对请求定义强制配额，以控制客户端使用Broker资源。

## 31、Kafka的日志分段策略与刷新策略。
- 日志分段策略
    - 1、log.roll
- 日志刷新策略

# 八、分布式知识
## 1、分布式CAP原则？
- CAP原则有称为CAP定理，指的是一个分布式系统中，Consistency（一致性）、Availability（可用性）、Partition tolerance(分区容错性)这3个几把呢需求，最多只能同时满足其中的两个。
- Consistency一致性：值多个数据在多个副本之间能够保持一致的特性（严格的一致性）
- Availability可用性：之系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应。
- Partition tolerance(分区容错性)：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。

## 2、Base理论
- Base是Basic Available（基本可用）、Soft-state（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。Base理论是对CAP中一致性和可用性A权衡的结果。
- Base理论的核心思想：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。
1. 基本可用：指的是分布式系统出现不可预知故障的时候，允许损失部分可用性。
    - 什么叫部分可用性
        - 响应时间上的损失
        - 系统功能上的损失：正常情况下，用于可以使用系统的全部功能，但是由于系统访问量突然增加，系统的部分非核心功能无法使用。

2. 软状态：软状态值允许系统中的数据存在中间状态（CAP理论中的数据不一致）。并认为该状态的存在不会影响系统的整体可用性。机允许系统在不同节点的数据副本之间继续宁数据同的过程存在延时。
3. 最终一致性：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够到达一个一致的状态。因此，最终一致性的本质是需要系统保证最终数能够达到一直，而不需要实时保证系统数据的强一致性。
    - 分布式一致性的三个级别：
        - 1. 强一致性：系统写入什么，读出来就是什么
        - 2. 弱一致性：不一定可以读取到最新写入的值，也不保证多少时间后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一直的状态。
        - 3. 最终一致性：系统会保证一定时间内达到数据一致的状态。

##  3、分布式算法paxos
- 3种角色：
    - 1.Proposer（提议者）：提议者提提案，用于投票表决。
    - 2.Acceptor（接收者）：对提案进行投票，并接受达成共识的提案。
    - 3.Learner（学习者）：被告知投票的结果，接受达成共识的提案。
- 算法流程：Paxos算法包括两个阶段：第一个阶段Prepare（准备），第二个阶段Accept（接受）
    - Prepare阶段：
        1. 提议者提出一个新的方案[Mn,?],然受向接收者的某个超过半数的子集发出编号为Mn的准备请求。
        2. 如果一个接受者收到一个Mn的编号的准备请求，
    - Accept接受阶段：
        1.
        2.

## 4、分布式Raft算法
- 三种角色：
    - Leader（领导者）
    - Follower（跟随者）
    - Candidate（候选人）

## 5、分布式Gossip协议。
- 又称 epidemic 协议（epidemic protocol），是基于流行病传播方式的节点或者进程之间信息交换的协议，在分布式系统中被广泛使用，比如我们可以使用 gossip 协议来确保网络中所有节点的数据一样。
- Gossip协议：是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种协议，我们可以将信息传播给网络或者集群中的所有成员。
- 1.两种消息传播模式
    - 反熵（Anti-Entropy）和传谣（Rumor-Mongering）
    - 反熵就是指消除不同节点数据的差异，提升节点间数据的相似性，从而降低熵值。每隔时间段就随机选取某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异性，实现数据的最终一致性。
    - 谣言传播指的是分布式系统的一个节点一旦有了新数据之后，就会变成活跃节点，活跃节点会周期性的想其他节点发送新数据，知道所有的节点存储了该数据。
    
# 九、Java设计模式知识

## 设计模式的6大原则 ##
1. 开闭原则
2. 里氏替换原则
3. 依赖倒转原则
4. 接口隔离原则
5. 迪米特原则
6. 合成复用原则

## 23种设计模式 ##
### 1、创建型模式 ###
1. 工厂模式
2. 单例模式
3. 抽象工厂模式
4. 建造者模式
5. 原型模式
### 2、结构型模式 ###
1. 适配器模式
2. 桥接模式
3. 组合模式
4. 装饰器模式
5. 外观模式
6. 享元模式
7. 代理模式

### 3、行为模式
1. 访问者模式
2. 模版模式
3. 策略模式
4. 状态模式
5. 观察者模式：指多个对象之间存在一对多的以来关系，当一个对象的状态发生改变。所有以来他的对象都得到通知并自动更新。（Spring的事件驱动、监听器）
- 观察者模式的结构：
    1. 抽象主题:
    2. 具体主题
    3. 抽象观察者
    4. 具体观察者
6. 备忘录模式：
7. 中介者模式
8. 迭代器模式
9. 解释器模式
10. 命令模式
11. 责任链模式

